<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Introducción a Protocol Buffers - Dovixmans Blog</title><meta name=Description content="Dovixman tech blog"><meta property="og:title" content="Introducción a Protocol Buffers"><meta property="og:description" content="Protocol Buffers es el mecanismo diseñado por Google para serializar y deserializar datos estructurados. Google decidió crear este mecanismo como alternativa a XML o JSON, en busca de una forma más eficiente de serializar y deserializar los datos.
Protocol Buffer o Protobuf, es agnóstico del lenguaje y la plataforma utilizados para implementarlo, y está creado para ser extensible, lo que facilita la evolución y mantenimiento de este el la vida de un proyecto."><meta property="og:type" content="article"><meta property="og:url" content="http://dovixman.github.io/blog/introduccion-a-protocol-buffers/"><meta property="og:image" content="http://dovixman.github.io/images/avatar.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-15T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-15T02:02:33+02:00"><meta property="og:site_name" content="Dovixmans Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://dovixman.github.io/images/avatar.png"><meta name=twitter:title content="Introducción a Protocol Buffers"><meta name=twitter:description content="Protocol Buffers es el mecanismo diseñado por Google para serializar y deserializar datos estructurados. Google decidió crear este mecanismo como alternativa a XML o JSON, en busca de una forma más eficiente de serializar y deserializar los datos.
Protocol Buffer o Protobuf, es agnóstico del lenguaje y la plataforma utilizados para implementarlo, y está creado para ser extensible, lo que facilita la evolución y mantenimiento de este el la vida de un proyecto."><meta name=application-name content="Dovixman Blog"><meta name=apple-mobile-web-app-title content="Dovixman Blog"><meta name=theme-color content="#5bbad5"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=images/avatar.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/><link rel=prev href=http://dovixman.github.io/blog/streams-java-8/><link rel=stylesheet href=/blog/css/style.min.61c0835a1733ac3f92b41b61b403dca9b8d4a3a7e4021c89af2c45a731f6343a82bc7fb214f4926e2c4669c8d258218b7da5d0e86d081ec97f3c1d823d48df2e.css integrity="sha512-YcCDWhczrD+StBthtAPcqbjUo6fkAhyJryxFpzH2NDqCvH+yFPSSbixGacjSWCGLfaXQ6G0IHsl/PB2CPUjfLg=="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Introducción a Protocol Buffers","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/dovixman.github.io\/blog\/introduccion-a-protocol-buffers\/"},"image":["http:\/\/dovixman.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"protocol-buffers","wordcount":2034,"url":"http:\/\/dovixman.github.io\/blog\/introduccion-a-protocol-buffers\/","datePublished":"2019-05-15T00:00:00+00:00","dateModified":"2022-07-15T02:02:33+02:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":{"@type":"ImageObject","url":"http:\/\/dovixman.github.io\/blog\/images\/avatar.png","width":300,"height":300}},"author":{"@type":"Person","name":"David"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blog/ title="Dovixmans Blog"><span class=header-title-pre><i class='fas fa-terminal' aria-hidden=true></i></span><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/blog/posts/><i class='fas fa-comment-alt'></i> Posts </a><a class=menu-item href=/blog/tags/><i class='fas fa-tags'></i> Tags </a><a class=menu-item href=/blog/categories/><i class='fas fa-hashtag'></i> Categories </a><a class=menu-item href=/blog/about/><i class='fas fa-address-card'></i> About </a><a class=menu-item href=https://github.com/dovixman title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title="Dovixmans Blog"><span class=header-title-pre><i class='fas fa-terminal' aria-hidden=true></i></span><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/blog/posts/ title><i class='fas fa-comment-alt'></i>Posts</a><a class=menu-item href=/blog/tags/ title><i class='fas fa-tags'></i>Tags</a><a class=menu-item href=/blog/categories/ title><i class='fas fa-hashtag'></i>Categories</a><a class=menu-item href=/blog/about/ title><i class='fas fa-address-card'></i>About</a><a class=menu-item href=https://github.com/dovixman title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Introducción a Protocol Buffers</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://dovixman.io title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>David</a></span>&nbsp;<span class=post-category>included in <a href=/blog/categories/software-architecture/><i class="far fa-folder fa-fw" aria-hidden=true></i>software-architecture</a>&nbsp;<a href=/blog/categories/communication-protocols/><i class="far fa-folder fa-fw" aria-hidden=true></i>communication-protocols</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=15-05-2019>15-05-2019</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;2034 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;10 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#elemento-message>Elemento Message</a><ul><li><a href=#numeración>Numeración</a></li><li><a href=#tipos-de-campos>Tipos de campos</a></li><li><a href=#campos-reservados>Campos reservados</a></li><li><a href=#estructuras-de-datos-como-campos>Estructuras de datos como campos</a><ul><li><a href=#estructuras-anidadas>Estructuras anidadas</a></li></ul></li></ul></li><li><a href=#importando-protos>Importando &lsquo;<strong>.proto</strong>&rsquo;s</a></li><li><a href=#comentarios-en-ficheros-proto>Comentarios en ficheros ‘<strong>.proto</strong>’</a></li><li><a href=#enumerados>Enumerados</a><ul><li><a href=#aliases>Aliases</a></li></ul></li><li><a href=#otros-comandos>Otros comandos</a><ul><li><a href=#oneof>oneOf</a></li><li><a href=#maps>Maps</a></li><li><a href=#servicios>Servicios</a></li><li><a href=#mapeo-json>Mapeo JSON</a></li><li><a href=#opciones-dentro-del-proto>Opciones dentro del Proto</a></li></ul></li><li><a href=#compilando-el-proto-y-generando-código>Compilando el ‘<strong>.proto</strong>’ y generando código</a></li></ul></nav></div></div><div class=content id=content><p><strong><em>Protocol Buffers</em></strong> es el mecanismo diseñado por Google para serializar y deserializar datos estructurados. Google decidió crear este mecanismo como alternativa a XML o JSON, en busca de una forma más eficiente de serializar y deserializar los datos.</p><p>Protocol Buffer o Protobuf, es agnóstico del lenguaje y la plataforma utilizados para implementarlo, y está creado para ser extensible, lo que facilita la evolución y mantenimiento de este el la vida de un proyecto. Sin embargo, una de las desventajas con respecto a XML o JSON, es que el número de lenguajes en el que podemos utilizarlo está limitado a los lenguajes que el <a href=https://developers.google.com/protocol-buffers/docs/tutorials target=_blank rel="noopener noreffer">compilador tiene implementados</a>.</p><p>Su funcionamiento es sencillo, se define un fichero ‘<strong>.proto</strong>’ que contiene el esquema con el que queremos que los datos sean estructurados, y mediante el compilador que nos ofrece el equipo de Protocol Buffers para los distintos lenguajes, generamos las clases necesarias para implementar dicho esquema, y que nos permite serializar y deserializar mensajes de forma nativa.</p><p>La sintaxis de Protocol Buffers es sencilla, empecemos por el ejemplo más simple, definir un mensaje.</p><h2 id=elemento-message>Elemento Message</h2><p>&lsquo;<em><strong>message</strong></em>&rsquo; es el elemento que nos permite definir la estructura de datos que utilizar en nuestras comunicaciones.</p><p>Un fichero ‘<strong>.proto</strong>’ puede tener uno o varios elementos &lsquo;<em><strong>message</strong></em>&rsquo;, además de enumerados y comentarios como veremos más adelante.</p><p>syntax = &ldquo;proto3&rdquo;;</p><p>message SearchRequest {
string query = 1;
int32 page_number = 2;
int32 result_per_page = 3;
enum Corpus {
UNIVERSAL = 0;
WEB = 1;
IMAGES = 2;
LOCAL = 3;
NEWS = 4;
PRODUCTS = 5;
VIDEO = 6;
}
Corpus corpus = 4;
}</p><p>La primera línea del ejemplo define qué sintaxis vamos a utilizar, en este caso estamos definiendo que utilizaremos la sintaxis de la versión <a href=https://developers.google.com/protocol-buffers/docs/proto3 target=_blank rel="noopener noreffer">v3</a>. Si omitimos esta línea, el compilador asumirá que estamos utilizando la versión <a href=https://developers.google.com/protocol-buffers/docs/proto target=_blank rel="noopener noreffer">v2</a>.</p><p>La estructura que le sigue define el esquema que queremos que tengan nuestro elemento &lsquo;<strong><em>message</em></strong>&rsquo;. Para ello utilizamos la palabra reservada ‘<strong><em>message</em></strong>’ para definir que queremos crear una estructura de datos que compondrá un mensaje, y definimos el nombre de la estructura de datos como ‘<strong><em>SearchRequest</em></strong>’.</p><p>Una vez señalado el tipo de elemento que estamos definiendo, incluimos los datos que va a contener con el formato que veremos a continuación.</p><h3 id=numeración>Numeración</h3><p>Los campos de las estructuras de datos están numerados. Esta numeración se utiliza para identificar los campos una vez el mensaje está serializado, y no deberían cambiar una vez la estructura de datos está en uso, ya que puede derivar en errores de deserialización.</p><p>La numeración debe ser <strong>única</strong>, es decir, no puede haber índices repetidos, ya que de lo contrario el compilador nos lanzará un error.</p><p>El índice de datos que podemos utilizar va desde el 1 al 229 - 1, estando reservados para uso interno de Protocol Buffers los índices del 19000 al 19999.</p><p>Tal y como se especifica en la documentación, los índices del 1 al 15 ocupan un byte de espacio, mientras que los índices del 16 al 2047 ocupan 2 bytes, por lo que deberíamos reservar los primeros 15 índices para campos que se utilizan muy frecuentemente en la estructura de datos. Esto hará que las los procesos de serialización y deserialización sean más eficientes.</p><p>Esto significa que, pensando en la evolución que pueda tener el <strong><em>proto</em></strong>, deberíamos dejar cierto espacio de índices reservado para futuros campos a los que se les pueda llegar a dar mucho uso, utilizando para campos menos frecuentes los índices del 16 en adelante.</p><p>Todos los campos de un mensaje pueden anotarse con las palabras clave <strong>‘singular’</strong> y <strong>‘repeated’</strong>, que definen que el campo puede aparecer una o varias veces, respectivamente. A su vez, cada uno de los campos de la estructura de datos deberá definir el tipo, tal y como veremos a continuación.</p><h3 id=tipos-de-campos>Tipos de campos</h3><p>Los datos de una estructura de datos pueden ser de uno de los siguientes tipos:</p><table><tbody><tr><td><strong>Tipo en '.proto'</strong></td><td><strong>Tipo en Java</strong></td><td><strong>Valores por defecto</strong></td></tr><tr><td>float</td><td>float</td><td>0</td></tr><tr><td>int32, uint32, sint32, sfixed32</td><td>int</td><td>0</td></tr><tr><td>int64, uint64, sint64, sfixed64</td><td>long</td><td>0</td></tr><tr><td>bool</td><td>bool</td><td>false</td></tr><tr><td>string</td><td>String</td><td>String vacío</td></tr><tr><td>Bytes</td><td>ByteString</td><td>ByteString vacío</td></tr></tbody></table><p>Para saber más acerca de los tipos de datos y su codificación, podéis acceder a la <a href=https://developers.google.com/protocol-buffers/docs/encoding target=_blank rel="noopener noreffer">documentación oficial</a>.</p><h3 id=campos-reservados>Campos reservados</h3><p>En los campos de un mensaje, al igual que en los enumerados, los índices se pueden reservar utilizando la siguiente sintaxis.</p><p>message Foo {
reserved 2, 15, 9 to 11;
reserved &ldquo;foo&rdquo;, &ldquo;bar&rdquo;;
}</p><p>Podemos reservar tanto campos numéricos como textos, pero nunca mezclandolos en la misma línea.</p><h3 id=estructuras-de-datos-como-campos>Estructuras de datos como campos</h3><p>Las estructuras de datos pueden contener, a su vez, otras estructuras de datos:</p><p>message SearchResponse {
repeated Result results = 1;
}</p><p>message Result {
string url = 1;
string title = 2;
repeated string snippets = 3;
}</p><p>Para ello, podemos definir la estructura que vamos a utilizar como campo, y una vez definida, añadirla a otra estructura de datos, como en el ejemplo anterior.</p><p>Además, vemos como en el ejemplo se define el campo con la palabra ‘<strong><em>repeated</em></strong>’. Esta opción permite definir el campo anotado como un array de datos, y se puede utilizar con cualquier tipo definido en los apartados anteriores.</p><h4 id=estructuras-anidadas>Estructuras anidadas</h4><p>Siguiendo la misma lógica anterior, también podemos definir estructuras anidadas dentro de otras estructuras de datos, sin la necesidad de implementar las estructuras por separado, fuera del propio &lsquo;<strong><em>message</em></strong>&rsquo; contenedor:</p><p>message SearchResponse {
message Result {
string url = 1;
string title = 2;
repeated string snippets = 3;
}
repeated Result results = 1;
}</p><p>Uno de los aspectos que diferencia una estructura anidada, es que si queremos hacer uso de esta en otras estructuras, deberemos definirla de la siguiente manera:</p><p>message SomeOtherMessage {
SearchResponse.Result result = 1;
}</p><p>Se pueden anidar tantas estructuras de datos como se quieran, Protocol Buffers no define ningún límite en la anidación.</p><h2 id=importando-protos>Importando &lsquo;<strong>.proto</strong>&rsquo;s</h2><p>Protocol Buffers nos permite reutilizar los esquemas definidos mediante la importación de ‘<strong>.proto</strong>’s.</p><p>Para realizar una importación, solo tendremos que definir la siguiente línea en la cabecera del ‘<strong>.proto</strong>’ actual, y una vez importado, podremos utilizar los message definidos:</p><p>import &ldquo;myproject/other_protos.proto&rdquo;;</p><h2 id=comentarios-en-ficheros-proto>Comentarios en ficheros ‘<strong>.proto</strong>’</h2><p>Los ficheros <strong><em>‘.proto’</em></strong> se pueden comentar con la sintaxis habitual de Java, utilizando <em><strong>//</strong></em> y <em><strong>/* &mldr; */</strong></em>.</p><p>Estos comentarios se convertirán a comentarios del lenguaje seleccionado, documentando las clases generadas para facilitar su utilización.</p><p>/* SearchRequest represents a search query, with pagination options to indicate which results to include in the response. */</p><p>message SearchRequest {
string query = 1;
int32 page_number = 2; // Which page number do we want?
int32 result_per_page = 3; // Number of results to return per page.
}</p><h2 id=enumerados>Enumerados</h2><p>Los campos definidos en un &lsquo;<strong><em>message</em></strong>&rsquo; también pueden ser de tipo enumerados, que podemos crear tanto en la propia estructura de datos, como fuera de estas, como un elemento separado.</p><p>Un ejemplo de definición de los enumerados es la siguiente:</p><p>enum Corpus {
UNIVERSAL = 0;
WEB = 1;
IMAGES = 2;
LOCAL = 3;
NEWS = 4;
PRODUCTS = 5;
VIDEO = 6;
}</p><p>Al igual que los campos de una estructura de datos, los campos de los enumerados también están numerados, por los mismos motivos, pero con algunas diferencias.</p><p>La diferencia más relevante es que un enumerado <strong>siempre</strong> deberá tener un elemento con la numeración <strong><em>0</em></strong>. Esto es debido a que este valor se utilizará como valor por defecto, además de utilizarse para la retrocompatibilidad con la versión 2 de Protocol Buffers.</p><p>La problemática más habitual en enumerados y elementos &lsquo;<strong><em>message</em></strong>&rsquo; es la retrocompatibilidad de estos en las actualizaciones que eliminan uno o varios campos. Esto es debido a que al eliminar un campo, liberamos la numeración de este para poder ser utilizada por otro campo distinto, y esto puede llegar a causar conflictos de serialización entre versiones.</p><p>Para darle una solución, Protocol Buffers permite reservar el uso de ciertos valores mediante la palabra reservada ‘<em><strong>reserved</strong></em>’, con la cual podemos definir qué valores, ya sean numéricos o strings, queremos reservar para que no puedan ser utilizados en futuras actualizaciones. De esta manera restringimos los valores que podemos utilizar y aseguramos la retrocompatibilidad entre versiones.</p><p>enum Foo {
reserved 2, 15, 9 to 11, 40 to max;
reserved &ldquo;FOO&rdquo;, &ldquo;BAR&rdquo;;
}</p><h3 id=aliases>Aliases</h3><p>Los enumerados tienen otra particularidad, y es que permiten utilizar aliases. Los aliases son valores con el mismo índice que nos devolverán el mismo valor una vez implementados, pero manteniendo distinto texto.</p><p>Para utilizarlos tenemos que habilitarlos en el propio enumerado de la siguiente manera, de lo contrario el compilador nos lanzará un error al detectar numeración duplicada:</p><p>enum EnumAllowingAlias {
option allow_alias = true;
UNKNOWN = 0;
STARTED = 1;
RUNNING = 1;
}</p><p>Una vez habilitados, podremos definir varios elementos con la misma numeración, que se podrán utilizar como aliases para definir un mismo valor. En el caso anterior, los campos <em>STARTED</em>, y <em>RUNNING</em> tienen el mismo valor en el enumerado.</p><h2 id=otros-comandos>Otros comandos</h2><p>Además de los tipos básicos, Protocol Buffers nos ofrece ciertos comandos más complejos con los que podemos añadir cierta lógica y condicionamiento a los &lsquo;<strong><em>message</em></strong>&rsquo;.</p><h3 id=oneof>oneOf</h3><p>La palabra reservada ‘<strong>oneOf</strong>’ se utiliza para definir que, de un conjunto de campos, solo uno de ellos debe ser definido al mismo tiempo. Cuando se define un valor para uno de los campos dentro de esta estructura, se borra el valor del resto de campos que contiene.</p><p>message SampleMessage {
oneof test_oneof {
string name = 4;
SubMessage sub_message = 9;
}
}</p><p>Para saber cual de los campos ha sido el que se ha definido, Protocol Buffers implementado dos métodos que nos dan esta información en la compilación de las clases, el método <em><strong>case()</strong></em> y el método <em><strong>WhichOneOf()</strong></em>.</p><p>Una de las limitaciones de esta funcionalidad, es que no se pueden utilizar campos de tipo <strong>repeated</strong>.</p><h3 id=maps>Maps</h3><p>Protocol Buffers permite definir mapas de datos mediante la siguiente sintaxis:</p><p>map&lt;key_type, value_type> map_field = N;</p><p>Donde:</p><ul><li><strong>Key_type</strong>: Puede ser cualquier tipo de entero o string.</li><li><strong>Value_type</strong>: Puede ser cualquier tipo, excepto otro mapa.</li></ul><p>Por otro lado, los campos de un mapa no pueden ser de tipo ‘<strong>repeated</strong>’, y el mapa no tiene porque guardar el orden original en el que se insertaron los datos.</p><h3 id=servicios>Servicios</h3><p>De querer utilizar los protos definidos en un sistema de RPC, Protocol Buffers permite definir un servicio que especifica el contrato que se deberá cumplir para poder utilizar el mensaje con el protocolo RPC.</p><p>service SearchService {
rpc Search (SearchRequest) returns (SearchResponse);
}</p><p>La implementación del protocolo de comunicaciones RPC más común a utilizar con Protocol Buffers es gRPC, un sistema RPC agnóstico de lenguaje y plataforma, también creado por Google, que permite generar el código necesario para la comunicación RPC directamente en la compilación de los ficheros ‘<strong><em>.proto</em></strong>’.</p><p>Si somos muy puristas, podemos definir nuestra propia implementación para la comunicación RPC siguiendo <a href=https://developers.google.com/protocol-buffers/docs/proto#services target=_blank rel="noopener noreffer">esta guía</a>.</p><h3 id=mapeo-json>Mapeo JSON</h3><p>Protocol Buffers nos permite mapear nuestros datos al formato JSON para facilitar la exportación e importación de datos, además de facilitar la integración con servicios externos.</p><h3 id=opciones-dentro-del-proto>Opciones dentro del Proto</h3><p>Además de la definición de la sintaxis, existen otras opciones disponibles para los ficheros ‘<strong>.proto</strong>’:</p><ul><li><strong>Option java_package</strong>: define el package en el que se generarán las clases compiladas.</li><li><strong>Option java_multiple_files</strong>: Permite que las clases se generen en clases separadas dentro del package definido, en vez de generarse en clases abstractas dentro de una clase principal.</li><li><strong>Option java_outer_classname</strong>: Nombre de la clase principal que contendrá, si no se define lo contrario, todas las clases generadas a partir del fichero de ‘.proto’. Si no se define ningun valor, este se recogerá de la conversión a Camel Case del nombre del fichero de ‘.proto’.</li><li><strong>Option optimize_for</strong>: Permite definir la optimización del código generado para: La velocidad (SPEED), el tamaña de código (CODE_SIZE) o el uso de la librería Lite de Protocol Buffers (LITE_RUNTIME).</li><li><strong>Int32 old_field = 4 [deprecated=true]</strong>: Marca como deprecado el campo marcado.</li></ul><h2 id=compilando-el-proto-y-generando-código>Compilando el ‘<strong>.proto</strong>’ y generando código</h2><p>Para generar el código a partir del fichero ‘<strong><em>.proto</em></strong>’, deberemos utilizar la opción pertinente para cada lenguaje en el compilador. El comando para la compilación y generación de código es el siguiente, en el que podemos ver los distintos lenguajes soportados:</p><p>protoc &ndash;proto_path=IMPORT_PATH &ndash;cpp_out=DST_DIR &ndash;java_out=DST_DIR &ndash;python_out=DST_DIR &ndash;go_out=DST_DIR &ndash;ruby_out=DST_DIR &ndash;objc_out=DST_DIR &ndash;csharp_out=DST_DIR path/to/file.proto</p><p>Donde:</p><ul><li><strong>IMPORT_PATH:</strong> Define el path donde el compilador buscará los ficheros ‘<strong>.proto</strong>’.</li><li><strong>*_output</strong>: Define los paths de salida para el código generado para los múltiples lenguajes soportados por el compilador.</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 15-07-2022</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/ data-title="Introducción a Protocol Buffers" data-hashtags=protocol-buffers><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/ data-hashtag=protocol-buffers><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Linkedin" data-sharer=linkedin data-url=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/><i class="fab fa-linkedin fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on WhatsApp" data-sharer=whatsapp data-url=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/ data-title="Introducción a Protocol Buffers" data-web><i class="fab fa-whatsapp fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Reddit" data-sharer=reddit data-url=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/><i class="fab fa-reddit fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Instapaper" data-sharer=instapaper data-url=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/ data-title="Introducción a Protocol Buffers" data-description><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/instapaper.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Pocket" data-sharer=pocket data-url=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/><i class="fab fa-get-pocket fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Flipboard" data-sharer=flipboard data-url=http://dovixman.github.io/blog/introduccion-a-protocol-buffers/ data-title="Introducción a Protocol Buffers"><i class="fab fa-flipboard fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/blog/tags/protocol-buffers/>protocol-buffers</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/blog/>Home</a></span></section></div><div class=post-nav><a href=/blog/streams-java-8/ class=prev rel=prev title="Java 8: Streams"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Java 8: Streams</a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://dovixman.io target=_blank>David</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},data:{"id-1":"Dovixman Blog","id-2":"Dovixman Blog"},twemoji:!0,typeit:{cursorChar:"_",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:150}}</script><script type=text/javascript src=/blog/js/theme.min.8f3907fa55b08d1250417a302a5836b4095aeba0e8de276226fbabed0058c004aec93be43d27a90cb1c7b80dffd331535aae064d507b1c9f140b42edb18d7d90.js integrity="sha512-jzkH+lWwjRJQQXowKlg2tAla66Do3idiJvur7QBYwASuyTvkPSepDLHHuA3/0zFTWq4GTVB7HJ8UC0LtsY19kA=="></script></body></html>