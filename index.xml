<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Dovixmans Blog</title><link>https://dovixman.io/</link><description>This is my cool site</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 02 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://dovixman.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Climbing the Engineering Ladder: From Junior Developer to Technical Lead</title><link>https://dovixman.io/software-egineering-lather-en/</link><pubDate>Tue, 02 May 2023 00:00:00 +0000</pubDate><author>Author</author><guid>https://dovixman.io/software-egineering-lather-en/</guid><description><![CDATA[<h1 id="climbing-the-engineering-ladder-from-junior-developer-to-technical-lead">Climbing the Engineering Ladder: From Junior Developer to Technical Lead</h1>
<p>For the Spanish version go <a href="/software-engineering-lather" rel="">here</a>.</p>
<p>The journey from a junior developer to a Technical Lead is an incredible feat that requires continuous learning, adaptation, and growth. This article aims to provide insights into the necessary technical and soft skills needed at each step of this career ladder, along with recommended reads for each level.</p>
<p>The following list of recommended books does not contain any language-specific suggestions, as its objective is to be relevant to developers working with any programming language. The selection aims to cover a broad range of topics to facilitate the growth and development of software engineering professionals at every stage of their careers.</p>]]></description></item><item><title>Escalando la Escalera de la Ingeniería: Desde Desarrollador Junior hasta Líder Técnico</title><link>https://dovixman.io/software-egineering-lather/</link><pubDate>Tue, 02 May 2023 00:00:00 +0000</pubDate><author>Author</author><guid>https://dovixman.io/software-egineering-lather/</guid><description><![CDATA[<h1 id="escalando-la-escalera-de-la-ingeniería-desde-desarrollador-junior-hasta-líder-técnico">Escalando la Escalera de la Ingeniería: Desde Desarrollador Junior hasta Líder Técnico</h1>
<p>Para la versión en inglés ve <a href="/software-engineering-lather-en" rel="">aquí</a>.</p>
<p>El viaje de un desarrollador junior a un líder técnico es una hazaña increíble que requiere aprendizaje continuo, adaptación y crecimiento. Este artículo tiene como objetivo proporcionar información sobre las habilidades técnicas y blandas necesarias en cada paso de esta escalera profesional, junto con lecturas recomendadas para cada nivel.</p>
<p>La siguiente lista de libros recomendados no contiene sugerencias específicas de lenguaje, ya que su objetivo es ser relevante para los desarrolladores que trabajan con cualquier lenguaje de programación. La selección tiene como objetivo cubrir una amplia gama de temas para facilitar el crecimiento y desarrollo de los profesionales de la ingeniería de software en cada etapa de sus carreras.</p>]]></description></item><item><title>Introducción a Protocol Buffers</title><link>https://dovixman.io/introduccion-a-protocol-buffers/</link><pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate><author>Author</author><guid>https://dovixman.io/introduccion-a-protocol-buffers/</guid><description><![CDATA[<p><strong><em>Protocol Buffers</em></strong> es el mecanismo diseñado por Google para serializar y deserializar datos estructurados. Google decidió crear este mecanismo como alternativa a XML o JSON, en busca de una forma más eficiente de serializar y deserializar los datos.</p>
<p>Protocol Buffer o Protobuf, es agnóstico del lenguaje y la plataforma utilizados para implementarlo, y está creado para ser extensible, lo que facilita la evolución y mantenimiento de este el la vida de un proyecto. Sin embargo, una de las desventajas con respecto a XML o JSON, es que el número de lenguajes en el que podemos utilizarlo está limitado a los lenguajes que el <a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener noreffer ">compilador tiene implementados</a>.</p>]]></description></item><item><title>Java 8: Streams</title><link>https://dovixman.io/streams-java-8/</link><pubDate>Wed, 03 Apr 2019 00:00:00 +0000</pubDate><author>Author</author><guid>https://dovixman.io/streams-java-8/</guid><description><![CDATA[<p>Junto con las <a href="https://davidfuentes.blog/2019/02/03/java-8-expresiones-lambda/" target="_blank" rel="noopener noreffer ">expresiones lambda</a>, los <em>Streams</em> son una de las funcionalidades más relevantes de Java 8, y trae consigo una nueva forma de trabajar. Mediante una capa de abstracción, los <em>Streams</em> nos permiten definir la lógica de negocio como un conjunto de funciones que se ejecutan de forma anidada.</p>
<p>De este modo, podemos trabajar con colecciones utilizando el paradigma de programación funcional, que nos permite definir las funciones a ejecutar de una forma mucho más clara y, en cierto modo, lo más parecida posible a como lo haríamos las personas en una situación real.</p>]]></description></item><item><title>Java 8: Novedades en interfaces</title><link>https://dovixman.io/novedades-en-interfaces-java-8/</link><pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate><author>Author</author><guid>https://dovixman.io/novedades-en-interfaces-java-8/</guid><description><![CDATA[<p>Hasta Java 8, las interfaces únicamente podían implementar métodos públicos y abstractos por defecto.</p>
<p>En la versión de Java 8 esto ha cambiado, se ha extendido la funcionalidad de las interfaces, de modo que puedan albergar métodos <em><strong>estáticos</strong></em> y métodos <em><strong>default</strong></em> que nos permiten definir lógica de negocio dentro de las propias interfaces.</p>
<h2 id="métodos-default">Métodos default</h2>
<p>El objetivo que se persigue con este tipo de funcionalidad es dar a las interfaces la capacidad de definir un comportamiento estándar para toda clase que las implemente, pudiendo especializar cualquiera de los métodos definidos sobreescribiéndolos en la propia implementación de la clase.</p>]]></description></item><item><title>Java 8: Referencias a métodos y constructores</title><link>https://dovixman.io/referencias-metodos-constructores-java-8/</link><pubDate>Mon, 18 Mar 2019 00:00:00 +0000</pubDate><author>Author</author><guid>https://dovixman.io/referencias-metodos-constructores-java-8/</guid><description><![CDATA[<p>La referenciación a métodos y constructores es otra de las funcionalidades que nos ofrece Java 8, y que nos permite utilizar dichas referencias a modo de <a href="https://davidfuentes.blog/2019/02/03/java-8-expresiones-lambda/" target="_blank" rel="noopener noreffer "></a><strong><em><a href="https://davidfuentes.blog/2019/02/03/java-8-expresiones-lambda/" target="_blank" rel="noopener noreffer ">expresiones lambda</a></em></strong>.</p>
<p>Estas referencias son lo que en inglés se denomina &ldquo;<em><a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener noreffer ">syntactic sugar</a></em>&rdquo;, y consiste en pequeños añadidos a la sintaxis de Java diseñados para hacer algunas construcciones más fáciles de leer o expresar.</p>
<p>Las referencias a métodos y constructores sólo pueden ser utilizadas cuando la <a href="https://davidfuentes.blog/2019/03/11/java-8-interfaces-funcionales/" target="_blank" rel="noopener noreffer "><strong><em>interfaz funcional</em></strong></a> coincide con el patrón del método referenciado.</p>]]></description></item><item><title>Java 8: Interfaces funcionales.</title><link>https://dovixman.io/interfaces-funcionales-java-8/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate><author>Author</author><guid>https://dovixman.io/interfaces-funcionales-java-8/</guid><description><![CDATA[<p>Las interfaces funcionales son todas aquellas interfaces que definen un único método abstracto, pudiendo implementar uno o varios métodos <strong><em>default</em></strong> o <strong><em>static</em></strong>.</p>
<p>Este nuevo tipo de interfaces son especialmente importantes debido a que son la base de la implementación de las nuevas <a href="https://davidfuentes.blog/2019/02/03/java-8-expresiones-lambda/" target="_blank" rel="noopener noreffer ">expresiones lambda</a>, una de las funcionalidades más importantes de Java 8.</p>
<p>A continuación podemos ver un ejemplo de interfaz funcional, en la que se define un único método abstracto, y varios métodos <strong><em>default</em></strong> y <strong><em>static</em></strong>:</p>]]></description></item><item><title>Java 8: Expresiones Lambda</title><link>https://dovixman.io/expresiones-lambda-java-8/</link><pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate><author>Author</author><guid>https://dovixman.io/expresiones-lambda-java-8/</guid><description><![CDATA[<p>Las expresiones lambda son una de las múltiples funcionalidades nuevas que nos ofrece Java 8. Estas expresiones son parte de los primeros pasos de Java hacia la programación funcional, y su cometido es introducirnos a las funciones anónimas mediante las cuales podemos definir el comportamiento de los objetos, y los datos que encapsulan.</p>
<blockquote>
<p><strong><em>¿En qué consiste la programación funcional?</em></strong>
La programación funcional es un paradigma de programación basado en las funciones matemáticas, que especifica que una función que recibe un parámetro X, siempre devolverá un resultado Y.<br>
Este paradigma permite definir comportamiento mediante funciones, pudiendo inyectarlo como parámetro de entrada en los objetos, o devolverlo como resultado de otro método.</p>]]></description></item></channel></rss>