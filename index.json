[{"categories":["software-architecture","communication-protocols"],"content":"Protocol Buffers es el mecanismo diseñado por Google para serializar y deserializar datos estructurados. Google decidió crear este mecanismo como alternativa a XML o JSON, en busca de una forma más eficiente de serializar y deserializar los datos. Protocol Buffer o Protobuf, es agnóstico del lenguaje y la plataforma utilizados para implementarlo, y está creado para ser extensible, lo que facilita la evolución y mantenimiento de este el la vida de un proyecto. Sin embargo, una de las desventajas con respecto a XML o JSON, es que el número de lenguajes en el que podemos utilizarlo está limitado a los lenguajes que el compilador tiene implementados. Su funcionamiento es sencillo, se define un fichero ‘.proto’ que contiene el esquema con el que queremos que los datos sean estructurados, y mediante el compilador que nos ofrece el equipo de Protocol Buffers para los distintos lenguajes, generamos las clases necesarias para implementar dicho esquema, y que nos permite serializar y deserializar mensajes de forma nativa. La sintaxis de Protocol Buffers es sencilla, empecemos por el ejemplo más simple, definir un mensaje. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:0:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Elemento Message ‘message’ es el elemento que nos permite definir la estructura de datos que utilizar en nuestras comunicaciones. Un fichero ‘.proto’ puede tener uno o varios elementos ‘message’, además de enumerados y comentarios como veremos más adelante. syntax = \"proto3\"; message SearchRequest { string query = 1; int32 page\\_number = 2; int32 result\\_per\\_page = 3; enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Corpus corpus = 4; } La primera línea del ejemplo define qué sintaxis vamos a utilizar, en este caso estamos definiendo que utilizaremos la sintaxis de la versión v3. Si omitimos esta línea, el compilador asumirá que estamos utilizando la versión v2. La estructura que le sigue define el esquema que queremos que tengan nuestro elemento ‘message’. Para ello utilizamos la palabra reservada ‘message’ para definir que queremos crear una estructura de datos que compondrá un mensaje, y definimos el nombre de la estructura de datos como ‘SearchRequest’. Una vez señalado el tipo de elemento que estamos definiendo, incluimos los datos que va a contener con el formato que veremos a continuación. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:1:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Numeración Los campos de las estructuras de datos están numerados. Esta numeración se utiliza para identificar los campos una vez el mensaje está serializado, y no deberían cambiar una vez la estructura de datos está en uso, ya que puede derivar en errores de deserialización. La numeración debe ser única, es decir, no puede haber índices repetidos, ya que de lo contrario el compilador nos lanzará un error. El índice de datos que podemos utilizar va desde el 1 al $2^{29} - 1$, estando reservados para uso interno de Protocol Buffers los índices del 19000 al 19999. Tal y como se especifica en la documentación, los índices del 1 al 15 ocupan un byte de espacio, mientras que los índices del 16 al 2047 ocupan 2 bytes, por lo que deberíamos reservar los primeros 15 índices para campos que se utilizan muy frecuentemente en la estructura de datos. Esto hará que las los procesos de serialización y deserialización sean más eficientes. Esto significa que, pensando en la evolución que pueda tener el proto, deberíamos dejar cierto espacio de índices reservado para futuros campos a los que se les pueda llegar a dar mucho uso, utilizando para campos menos frecuentes los índices del 16 en adelante. Todos los campos de un mensaje pueden anotarse con las palabras clave ‘singular’ y ‘repeated’, que definen que el campo puede aparecer una o varias veces, respectivamente. A su vez, cada uno de los campos de la estructura de datos deberá definir el tipo, tal y como veremos a continuación. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:1:1","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Tipos de campos Los datos de una estructura de datos pueden ser de uno de los siguientes tipos: Tipo en '.proto'Tipo en JavaValores por defectofloatfloat0int32, uint32, sint32, sfixed32int0int64, uint64, sint64, sfixed64long0boolboolfalsestringStringString vacíoBytesByteStringByteString vacío Para saber más acerca de los tipos de datos y su codificación, podéis acceder a la documentación oficial. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:1:2","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Campos reservados En los campos de un mensaje, al igual que en los enumerados, los índices se pueden reservar utilizando la siguiente sintaxis. message Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\"; } Podemos reservar tanto campos numéricos como textos, pero nunca mezclandolos en la misma línea. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:1:3","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Estructuras de datos como campos Las estructuras de datos pueden contener, a su vez, otras estructuras de datos: message SearchResponse { repeated Result results = 1; } message Result { string url = 1; string title = 2; repeated string snippets = 3; } Para ello, podemos definir la estructura que vamos a utilizar como campo, y una vez definida, añadirla a otra estructura de datos, como en el ejemplo anterior. Además, vemos como en el ejemplo se define el campo con la palabra ‘repeated’. Esta opción permite definir el campo anotado como un array de datos, y se puede utilizar con cualquier tipo definido en los apartados anteriores. Estructuras anidadas Siguiendo la misma lógica anterior, también podemos definir estructuras anidadas dentro de otras estructuras de datos, sin la necesidad de implementar las estructuras por separado, fuera del propio ‘message’ contenedor: message SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1; } Uno de los aspectos que diferencia una estructura anidada, es que si queremos hacer uso de esta en otras estructuras, deberemos definirla de la siguiente manera: message SomeOtherMessage { SearchResponse.Result result = 1; } Se pueden anidar tantas estructuras de datos como se quieran, Protocol Buffers no define ningún límite en la anidación. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:1:4","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Importando ‘.proto’s Protocol Buffers nos permite reutilizar los esquemas definidos mediante la importación de ‘.proto’s. Para realizar una importación, solo tendremos que definir la siguiente línea en la cabecera del ‘.proto’ actual, y una vez importado, podremos utilizar los message definidos: import \"myproject/other\\_protos.proto\"; ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:2:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Comentarios en ficheros ‘.proto’ Los ficheros ‘.proto’ se pueden comentar con la sintaxis habitual de Java, utilizando // y /* … */. Estos comentarios se convertirán a comentarios del lenguaje seleccionado, documentando las clases generadas para facilitar su utilización. /\\* SearchRequest represents a search query, with pagination options to indicate which results to include in the response. \\*/ message SearchRequest { string query = 1; int32 page\\_number = 2; // Which page number do we want? int32 result\\_per\\_page = 3; // Number of results to return per page. } ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:3:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Enumerados Los campos definidos en un ‘message’ también pueden ser de tipo enumerados, que podemos crear tanto en la propia estructura de datos, como fuera de estas, como un elemento separado. Un ejemplo de definición de los enumerados es la siguiente: enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Al igual que los campos de una estructura de datos, los campos de los enumerados también están numerados, por los mismos motivos, pero con algunas diferencias. La diferencia más relevante es que un enumerado siempre deberá tener un elemento con la numeración 0. Esto es debido a que este valor se utilizará como valor por defecto, además de utilizarse para la retrocompatibilidad con la versión 2 de Protocol Buffers. La problemática más habitual en enumerados y elementos ‘message’ es la retrocompatibilidad de estos en las actualizaciones que eliminan uno o varios campos. Esto es debido a que al eliminar un campo, liberamos la numeración de este para poder ser utilizada por otro campo distinto, y esto puede llegar a causar conflictos de serialización entre versiones. Para darle una solución, Protocol Buffers permite reservar el uso de ciertos valores mediante la palabra reservada ‘reserved’, con la cual podemos definir qué valores, ya sean numéricos o strings, queremos reservar para que no puedan ser utilizados en futuras actualizaciones. De esta manera restringimos los valores que podemos utilizar y aseguramos la retrocompatibilidad entre versiones. enum Foo { reserved 2, 15, 9 to 11, 40 to max; reserved \"FOO\", \"BAR\"; } ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:4:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Aliases Los enumerados tienen otra particularidad, y es que permiten utilizar aliases. Los aliases son valores con el mismo índice que nos devolverán el mismo valor una vez implementados, pero manteniendo distinto texto. Para utilizarlos tenemos que habilitarlos en el propio enumerado de la siguiente manera, de lo contrario el compilador nos lanzará un error al detectar numeración duplicada: enum EnumAllowingAlias { option allow\\_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 1; } Una vez habilitados, podremos definir varios elementos con la misma numeración, que se podrán utilizar como aliases para definir un mismo valor. En el caso anterior, los campos STARTED, y RUNNING tienen el mismo valor en el enumerado. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:4:1","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Otros comandos Además de los tipos básicos, Protocol Buffers nos ofrece ciertos comandos más complejos con los que podemos añadir cierta lógica y condicionamiento a los ‘message’. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:5:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"oneOf La palabra reservada ‘oneOf’ se utiliza para definir que, de un conjunto de campos, solo uno de ellos debe ser definido al mismo tiempo. Cuando se define un valor para uno de los campos dentro de esta estructura, se borra el valor del resto de campos que contiene. message SampleMessage { oneof test\\_oneof { string name = 4; SubMessage sub\\_message = 9; } } Para saber cual de los campos ha sido el que se ha definido, Protocol Buffers implementado dos métodos que nos dan esta información en la compilación de las clases, el método case() y el método WhichOneOf(). Una de las limitaciones de esta funcionalidad, es que no se pueden utilizar campos de tipo repeated. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:5:1","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Maps Protocol Buffers permite definir mapas de datos mediante la siguiente sintaxis: map\u003ckey\\_type, value\\_type\u003e map\\_field = N; Donde: Key_type: Puede ser cualquier tipo de entero o string. Value_type: Puede ser cualquier tipo, excepto otro mapa. Por otro lado, los campos de un mapa no pueden ser de tipo ‘repeated’, y el mapa no tiene porque guardar el orden original en el que se insertaron los datos. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:5:2","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Servicios De querer utilizar los protos definidos en un sistema de RPC, Protocol Buffers permite definir un servicio que especifica el contrato que se deberá cumplir para poder utilizar el mensaje con el protocolo RPC. service SearchService { rpc Search (SearchRequest) returns (SearchResponse); } La implementación del protocolo de comunicaciones RPC más común a utilizar con Protocol Buffers es gRPC, un sistema RPC agnóstico de lenguaje y plataforma, también creado por Google, que permite generar el código necesario para la comunicación RPC directamente en la compilación de los ficheros ‘.proto’. Si somos muy puristas, podemos definir nuestra propia implementación para la comunicación RPC siguiendo esta guía. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:5:3","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Mapeo JSON Protocol Buffers nos permite mapear nuestros datos al formato JSON para facilitar la exportación e importación de datos, además de facilitar la integración con servicios externos. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:5:4","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Opciones dentro del Proto Además de la definición de la sintaxis, existen otras opciones disponibles para los ficheros ‘.proto’: Option java_package: define el package en el que se generarán las clases compiladas. Option java_multiple_files: Permite que las clases se generen en clases separadas dentro del package definido, en vez de generarse en clases abstractas dentro de una clase principal. Option java_outer_classname: Nombre de la clase principal que contendrá, si no se define lo contrario, todas las clases generadas a partir del fichero de ‘.proto’. Si no se define ningun valor, este se recogerá de la conversión a Camel Case del nombre del fichero de ‘.proto’. Option optimize_for: Permite definir la optimización del código generado para: La velocidad (SPEED), el tamaña de código (CODE_SIZE) o el uso de la librería Lite de Protocol Buffers (LITE_RUNTIME). Int32 old_field = 4 [deprecated=true]: Marca como deprecado el campo marcado. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:5:5","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Compilando el ‘.proto’ y generando código Para generar el código a partir del fichero ‘.proto’, deberemos utilizar la opción pertinente para cada lenguaje en el compilador. El comando para la compilación y generación de código es el siguiente, en el que podemos ver los distintos lenguajes soportados: protoc --proto\\_path=IMPORT\\_PATH --cpp\\_out=DST\\_DIR --java\\_out=DST\\_DIR --python\\_out=DST\\_DIR --go\\_out=DST\\_DIR --ruby\\_out=DST\\_DIR --objc\\_out=DST\\_DIR --csharp\\_out=DST\\_DIR path/to/file.proto Donde: IMPORT_PATH: Define el path donde el compilador buscará los ficheros ‘.proto’. *_output: Define los paths de salida para el código generado para los múltiples lenguajes soportados por el compilador. ","date":"15-05-2019","objectID":"/introduccion-a-protocol-buffers/:6:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/introduccion-a-protocol-buffers/"},{"categories":["java"],"content":"Junto con las expresiones lambda, los Streams son una de las funcionalidades más relevantes de Java 8, y trae consigo una nueva forma de trabajar. Mediante una capa de abstracción, los Streams nos permiten definir la lógica de negocio como un conjunto de funciones que se ejecutan de forma anidada. De este modo, podemos trabajar con colecciones utilizando el paradigma de programación funcional, que nos permite definir las funciones a ejecutar de una forma mucho más clara y, en cierto modo, lo más parecida posible a como lo haríamos las personas en una situación real. El siguiente código muestra la lógica de un programa que filtra una lista de enteros, y devuelve el valor más pequeño de la lista, sin tener en cuenta los números pares: public static void main(String\\[\\] args) { List\u003cInteger\u003e integers = Arrays.asList(3, 12, 21, 4, 2, 7, 5); Integer min = integers.get(0); for (Integer next : integers) { if (next % 2 == 0) continue; if (next \u003c min) { min = next; } } System.out.println(min); } Ahora veremos cómo se escribiría este mismo código utilizando Streams. public static void main(String\\[\\] args) { List\u003cInteger\u003e integers = Arrays.asList(3, 12, 21, 4, 2, 7, 5); Optional\u003cInteger\u003e min = integers.stream() .filter(integer -\u003e integer % 2 != 0) .min(Integer::compareTo); System.out.println(min.get()); } Como se puede observar, el código queda mucho más claro, ya que se organiza por funciones anidadas, que se ejecutan como un flujo de trabajo, generando nuevos _Stream_s a medida que avanzan en la cadena de ejecución. ","date":"03-04-2019","objectID":"/streams-java-8/:0:0","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/streams-java-8/"},{"categories":["java"],"content":"Elementos de un Stream Como ya he comentado, los Streams son abstracciones que nos permiten definir operaciones agregadas sobre una fuente de datos utilizando funciones. Los Streams se componen de tres partes: La fuente de datos Las operaciones intermedias La operación terminal // Fuente de datos: 1 Stream.of(“Some, Comma, Separated, Values”) // Operaciones intermedias: 0 -\u003e N .flatMap(string -\u003e Stream.of(string.split(\",\"))) .map(string -\u003e string.trim()) //Operación terminal: 1 .forEach(System.out::println); ","date":"03-04-2019","objectID":"/streams-java-8/:1:0","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/streams-java-8/"},{"categories":["java"],"content":"Fuentes de datos La fuente de datos consiste en una colección de datos que pueden ser tratados como una cadena de valores. Java ofrece distintas fuentes de Streams para ciertas clases: Collection.stream()JarFile.stream() ZipFile.stream()Collection.parallelStream()BufferedReader.lines()Arrays.stream()Pattern.splitAsStream()Files.find(Path, BiPredicate, FileVisitOption)CharSequence.chars()Files.list(Path)CharSequence.codePoints()Files.lines(Path)BitSet.stream()Files.walk(Path, FileVisitOption)Random().Ints() Random().Doubles() Random().Longs() También podemos utilizar métodos estáticos para crear Streams a partir de datos existentes: Stream.concat(Stream, Stream)Concatena dos Streams existentes y devuelve el Stream resultante.Stream.of(T… values)Crea un Stream a partir de los valores de entrada.IntStream.range(int, int)Stream de enteros entre los dos valores dados como parámetros de entrada.Stream.generate(IntSuppliert)Stream generado por un proveedor de resultados. Ejemplo: Stream.generate(new Random()::nextInt) Stream.iterate(int, IntUnaryOperator)El método Iterate() utiliza un valor como semilla para generar el Stream. ","date":"03-04-2019","objectID":"/streams-java-8/:1:1","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/streams-java-8/"},{"categories":["java"],"content":"Operaciones intermedias Las operaciones intermedias son operaciones que se aplican sobre la fuente de Stream definida. Estas operaciones no se ejecutan hasta que no se incluye una operación terminal en la secuencia de operaciones, que es la que causa que la cadena de operaciones se ejecute. La mayoría de las operaciones intermedias reciben un parámetro (interfaz funcional) que define su comportamiento, generalmente utilizando expresiones lambda. Como resultado, todas las operaciones intermedias devuelven un Stream, para que se puedan seguir concatenando operaciones. El comportamiento definido para estas operaciones debe ser no interferentes sobre la ejecución del Stream, esto significa que la ejecución de la operación actual no debe afectar al resto. También deben ser stateless, es decir, debe tratar cada ejecución independientemente, sin relacionar las ejecuciones entre sí. Estos dos patrones de comportamiento permite que un Stream pueda ser ejecutado de forma secuencial o paralela, sin necesidad de modificaciones, y definiendo su comportamiento en tiempo de ejecución. Existen múltiples operaciones intermedias, a continuación veremos las más frecuentes. Operaciones de filtrado y mapeado distinct()Devuelve un Stream sin elementos duplicados.filter(Predicate)Devuelve un Stream únicamente con los elementos que devuelven true al Predicate definido.map(Function)Devuelve un Stream en el cual se le aplica la función definida a cada uno de los elementos del Stream original.mapToInt(Function) Devuelve un Stream de enteros aplicando la función definida a cada uno de los elementos del Stream original.mapToDouble(Function)Devuelve un Stream de Doubles aplicando la función definida a cada uno de los elementos del Stream original.mapToLong(Function)Devuelve un Stream de Longs aplicando la función definida a cada uno de los elementos del Stream original. Además de las operaciones anteriores, existe un tipo de mapeado que devuelve múltiples resultados por cada valor procesado, este tipo de mapeado se denomina FlatMap. En la siguiente imagen se puede distinguir fácilmente la diferencia entre los Maps y los FlatMaps. Un ejemplo práctico sería el siguiente, en el cual creamos un Stream a partir de un String, haciendo un split por la coma utilizando el método FlatMap. Este método nos genera un nuevo Stream a partir de cada uno de los resultados obtenidos que podemos seguir procesando. public static void main(String\\[\\] args) { Stream.of(\"Some, Comma, Separated, Values\") .flatMap(string -\u003e Stream.of(string.split(\",\"))) .map(string -\u003e string.trim()) .forEach(System.out::println); } Operaciones de restricción de tamaño skip(Long n)Devuelve un Stream que ignora los primeros n elementos de la fuente de datos.limit(Long n)Devuelve un Stream que contiene los primeros n elementos de la fuente de datos. Operaciones de ordenación y desordenación sorted()Devuelve un Stream ordenado por ordenación natural. La ordenación natural es el orden el que un objeto primitivo debe ordenarse en una colección.sorter(Comparator)Devuelve un Stream ordenado mediante el Comparator recibido como parámetro de entrada.Unordered()Devuelve un Stream desordenado. Puede mejorar la eficiencia de otras operaciones como distinct() o groupingBy(). Observando los elementos de un Stream peek(Consumer)Devuelve un Stream idéntico al Stream del data source, aplicando la acción del Consumer a cada uno de los elementos. El método peek() no debería modificar los elementos del Stream. Generalmente utilizado para debugear. ","date":"03-04-2019","objectID":"/streams-java-8/:1:2","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/streams-java-8/"},{"categories":["java"],"content":"Operaciones terminales Las operaciones terminales son las que terminan el pipeline de operaciones de un Stream y activan su ejecución. Un Stream solo se ejecutará cuando el pipeline incluya una de estas operaciones. Al interpretar cómo se debe ejecutar la secuencia de operaciones del Stream, se aplican procesos de optimización para mergear o rechazar operaciones innecesarias, eliminar operaciones redundantes o ejecutar el stream en paralelo si fuera necesario. Las operaciones terminales generan un valor o una acción como resultado, esto hace que este tipo de operaciones cierren la cadena de ejecución, ya que no devuelve un Stream. Las operaciones terminales más comunes son las siguientes: Operaciones condicionales Optional\u003cT\u003e findFirst(Predicate)Devuelve el primer elemento del Stream que coincida con la condición del predicado, o un Optional vacío si no se cumple la condición.Optional\u003cT\u003e findAny(Predicate)Devuelve un elemento aleatorio del Stream que coincida con la condición del predicado, o un Optional vacío si no se cumple la condición. Pensado para ofrecer un mayor rendimiento en operaciones paralelas.Boolean allMatch(Predicate)Devuelve true si la condición del predicado se cumple para todos los elementos del Stream, false para el resto de casos.Boolean anyMatch(Predicate)Devuelve true si la condición del predicado se cumple para cualquier elemento del Stream, false para el resto de casos.Boolean noneMatch(Predicate)Devuelve true si la condición del predicado no se cumple para ningúnelemento del Stream, false para el resto de casos. Operaciones que devuelve colecciones collect(Collector)Devuelve el Stream en forma de colección del tipo que definamos. Podemos utilizar la clase de utilidad Collectors, que nos ofrece varias implementaciones de la interfaz Collector. toArray()Devuelve los elementos del Stream a modo de Array. Operaciones que devuelve resultados numéricos count()Devuelve un entero con el número de elementos que contiene el Stream.max(Comparator)Devuelve el valor más grande que contenga el Stream. Podemos definir el comparador que vamos a utilizar.min(Comparator)Devuelve el valor más pequeño que contenga el Stream. Podemos definir el comparador que vamos a utilizar.average()Devuelve la media aritmética del Stream.sum()Devuelve la suma de los elementos del Stream. Operaciones de iteración forEach(Consumer)Ejecuta la acción definida en el consumidor a cada elemento del Stream.forEach(Consumer)Realiza la misma acción que forEach() pero asegurando que el orden de ejecución se mantiene cuando se usa con Streams ejecutados de forma paralela. Operaciones de reducción reduce(BinaryOperator accumulator)Realiza una reducción en el Stream utilizando un BinaryOperator. El BinaryOperator recibe dos parámetros de entrada: el primero es el valor ya reducido, y el segundo es el valor a reducir. Esta acción se aplica a cada uno de los elementos del Stream. ","date":"03-04-2019","objectID":"/streams-java-8/:1:3","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/streams-java-8/"},{"categories":["java"],"content":"Hasta Java 8, las interfaces únicamente podían implementar métodos públicos y abstractos por defecto. En la versión de Java 8 esto ha cambiado, se ha extendido la funcionalidad de las interfaces, de modo que puedan albergar métodos estáticos y métodos default que nos permiten definir lógica de negocio dentro de las propias interfaces. ","date":"25-03-2019","objectID":"/novedades-en-interfaces-java-8/:0:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"Métodos default El objetivo que se persigue con este tipo de funcionalidad es dar a las interfaces la capacidad de definir un comportamiento estándar para toda clase que las implemente, pudiendo especializar cualquiera de los métodos definidos sobreescribiéndolos en la propia implementación de la clase. Esto evita las duplicaciones de código en clases que implementen el mismo comportamiento estándar. Además, facilita la extensión de nuestra arquitectura (Open/Closed principle), ya que al definir una implementación por defecto para los nuevos método en la interfaz, no estamos obligados a definirlos en cada una de las clases que la implementen, ofreciendo así cierta retrocompatibilidad. El siguiente ejemplo define una interfaz con un método default, y muestra cómo utilizarlo en una clase que lo implemente. public interface MyInterface { // Default method for getting \"Hello World\" String default String defaultHelloWorld(){ return \"Default Hello World!\"; } } class MyClass implements MyInterface { public static void main(String\\[\\] args) { MyClass myClass = new MyClass(); System.out.println(\"Default: \" + myClass.defaultHelloWorld()); } } Y obtenemos los resultados esperados. // Result Default: Default Hello World! ","date":"25-03-2019","objectID":"/novedades-en-interfaces-java-8/:1:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"Métodos estáticos Los métodos estáticos siguen la misma idea que los default, permitir definir lógica de negocio dentro de nuestra interfaz, y evitar así duplicados de código innecesarios. Y como he mencionado anteriormente, también ayudan a que nuestro código sea fácilmente extensible y mantenible. La diferencia con respecto a los métodos default, es que al ser estáticos, los métodos que definamos no serán sobreescribibles en las clases que implementen la interfaz. public interface MyInterface{ // Static method for getting \"Hello World\" String static String staticDefaultHelloWorld(){ return \"Static Hello World!\"; } } class MyClass implements MyInterface { public static void main(String\\[\\] args) { MyClass myClass = new MyClass(); System.out.println(\"Static: \" + MyClass.staticDefaultHelloWorld()); } } Y obtenemos los resultados. // Result Static: Static Hello World! Pero como siempre, con las nuevas funcionalidades, también se plantean diversas casuísticas que pueden llevarnos a confusión. ","date":"25-03-2019","objectID":"/novedades-en-interfaces-java-8/:2:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"Implementar múltiples interfaces con las mismas funciones default Utilizando los métodos default podría darse el caso de tener una clase que implemente varias interfaces, que contengan un mismo método. No hay jerarquía entre ambas interfaces, por lo que el compilador no sabrá cuál de las dos seleccionar a la hora de invocar el método. public interface Interface1 { default String getHelloWorldStr(){ return \"Hello world from Interface 1\"; } } public interface Interface2 { default String getHelloWorldStr(){ return \"Hello world from Interface 2\"; } } Por tanto, la clase que implemente ambas interfaces se verá obligada a sobrescribir el método getHelloWorld por el compilador, para evitar errores de compilación. public class HelloWorldClass implements Interface1, Interface2 { @Override public String getHelloWorldStr() { return \"Hello World from HelloWorldClass\"; } } ","date":"25-03-2019","objectID":"/novedades-en-interfaces-java-8/:3:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"El problema del diamante Existe un caso, muy parecido al anterior, llamado problema del diamante. Este problema consiste en la ambigüedad que surge como consecuencia de la herencia múltiple, y que provoca que el método que hay que invocar no pueda ser extraído mediante las reglas de resolución de conflictos de las interfaces de Java. Este es un problema común entre los lenguajes que permiten la herencia múltiple, y su nombre viene de la forma que toma la definición de esta arquitectura. Problema del diamante Imaginemos un escenario en el cual existen dos interfaces, Interface1 e Interface2, que extienden de una tercera interfaz Interface0. interface Interface0 { default String getHelloWorldStr(){ return \"Hello world from Interface 0\"; } } interface Interface1 extends Interface0{ default String getHelloWorldStr(){ return \"Hello world from Interface 1\"; } } interface Interface2 extends Interface0{ default String getHelloWorldStr(){ return \"Hello world from Interface 2\"; } } Como se puede observar en el código anterior, las interfaces Interface1, e Interface2 quedan al mismo nivel jerárquico, mientras que Interface0 queda por debajo de estas. Esto genera un problema, ya que al no existir una cadena jerárquica, el compilador no es capaz de inferir el método a utilizar, y nos forzará a reescribirlo explícitamente en nuestra clase. public class MyClass implements Interface1, Interface2 { // Overwritten method from both Interface1 and Interface2 interfaces. @Override public String getHelloWorldStr() { return \"Hello World from MyClass\"; } public static void main(String\\[\\] args) { MyClass myClass = new MyClass(); System.out.println(myClass.getHelloWorldStr()); } } Obteniendo como resultado el de la implementación de la clase. // Result Hello World from MyClass ","date":"25-03-2019","objectID":"/novedades-en-interfaces-java-8/:4:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"Reglas para la selección de métodos default Como he comentado antes, existen ciertas reglas que el compilador de Java aplica cuando necesita seleccionar la implementación de un método definido en múltiples interfaces, ya que la herencia múltiple necesita de este tipo de soluciones. El compilador necesita una jerarquía de prioridades que aplicar cuando existen múltiples instancias del mismo método al que se hace referencia desde distintas interfaces y clases. Por este motivo, el compilador aplica una serie de reglas para aplicar dicha jerarquía: La implementación de las clases o superclases siempre tienen prioridad. public interface Interface1 { default String getHelloWorldStr(){ return \"Hello world from Interface 1\"; } } class HelloWorldClass implements Interface1{ @Override public String getHelloWorldStr() { return \"Hello World from HelloWorldClass\"; } public static void main(String\\[\\] args) { HelloWorldClass helloWorldClass = new HelloWorldClass (); System.out.println(helloWorldClass.getHelloWorldStr()); } } En este caso el resultado sería el definido en la implementación de la clase, que tiene prioridad con respecto al definido en la interfaz. // Result Hello World from HelloWorldClass Si no existe implementación para el método en la clase, siempre se utilizará la implementación del método default más específico definido en las interfaces heredadas public interface Interface1 { default String getHelloWorldStr(){ return \"Hello world from Interface 1\"; } } public interface Interface2 extends Interface1 { default String getHelloWorldStr(){ return \"Hello world from Interface 2\"; } } public class HelloWorldClass implements Interface1, Interface2 { public static void main(String\\[\\] args) { HelloWorldClass helloWorldClass = new HelloWorldClass (); System.out.println(helloWorldClass.getHelloWorldStr()); } } En este caso, la implementación del método de la interfaz Interface2 es la más específica en la cadena jerárquica, y será la que el compilador seleccione. // Result Hello world from Interface 2 ","date":"25-03-2019","objectID":"/novedades-en-interfaces-java-8/:5:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"La referenciación a métodos y constructores es otra de las funcionalidades que nos ofrece Java 8, y que nos permite utilizar dichas referencias a modo de expresiones lambda. Estas referencias son lo que en inglés se denomina “syntactic sugar”, y consiste en pequeños añadidos a la sintaxis de Java diseñados para hacer algunas construcciones más fáciles de leer o expresar. Las referencias a métodos y constructores sólo pueden ser utilizadas cuando la interfaz funcional coincide con el patrón del método referenciado. public static void main(String\\[\\] args){ // Normal lambda expression Consumer\u003cString\u003e consumer1 = (x) -\u003e System.out.println(x); consumer1.accept(\"Hello consumer1\"); // Lambda expression with a method reference Consumer\u003cString\u003e consumer2 = System.out::println; consumer2.accept(\"Hello consumer2\"); } En el siguiente ejemplo podemos ver que el patrón esperado por el compilador en el momento de definir la expresión lambda es la de la interfaz funcional Consumer, que recibe un parámetro de entrada, y no devuelve nada. Esto nos permite hacer referencia a métodos que tengan ese mismo patrón, como el que se hace referencia en el ejemplo, System.out::println. @FunctionalInterface public interface Consumer\u003cT\u003e { // Referenced method void accept(T t); default Consumer\u003cT\u003e andThen(Consumer\u003c? super T\u003e after) { Objects.requireNonNull(after); return (T t) -\u003e { accept(t); after.accept(t); }; } } Al tener la información necesaria para inferir los parámetros de entrada, los parámetros de salida y el comportamiento a aplicar en la expresión lambda, es el compilador el que hace el resto del trabajo por nosotros, pudiendo utilizar las referencias a métodos y constructores sin necesidad de definir cómo queremos utilizar las variables de entrada o salida, como haríamos con una expresión lambda basada en una interfaz funcional. Las reglas para utilizar las referencias mencionadas en expresiones lambda se pueden dividir en tres: Referencias a métodos estáticos Referencias a métodos sobre una instancia de un objeto Referencias a métodos sobre la instancia del objeto sobre el cual se crea la expresión lambda Reglas aplicables al referenciar métodos en expresiones lambda A continuación se puede encontrar un ejemplo de cada una de las reglas listadas en la imagen anterior: Ejemplo de referencias a métodos en expresiones lambda De la misma forma, para hacer referencia a un constructor, utilizamos la misma lógica anterior, utilizando la palabra clave new para instanciar el objeto. public static void main(String\\[\\] args){ // Normal constructor call Factory\u003cList\u003cString\u003e\u003e f = () -\u003e return new ArrayList\u003cString\u003e(); // Constructor reference call Factory\u003cList\u003cString\u003e\u003e f = ArrayList\u003cString\u003e::new; } ","date":"18-03-2019","objectID":"/referencias-metodos-constructores-java-8/:0:0","tags":["constructor-reference","method-reference"],"title":"Java 8: Referencias a métodos y constructores","uri":"/referencias-metodos-constructores-java-8/"},{"categories":["java"],"content":"Las interfaces funcionales son todas aquellas interfaces que definen un único método abstracto, pudiendo implementar uno o varios métodos default o static. Este nuevo tipo de interfaces son especialmente importantes debido a que son la base de la implementación de las nuevas expresiones lambda, una de las funcionalidades más importantes de Java 8. A continuación podemos ver un ejemplo de interfaz funcional, en la que se define un único método abstracto, y varios métodos default y static: public interface Calculator { // My abstract method String calculate(int arg1, int arg2); // Default method default int sum(int arg1, int arg2) { return arg1 + arg2; } // Static method static int floatToInt(float arg) { return Math.round(arg); } } Para asegurarnos de que nuestra interfaz funcional está bien implementada, Java 8 ha incluido una anotación que nos permite verificarlo, para ello deberemos incluir la anotación @FunctionalInterface a nivel de la clase. Esta anotación es procesada por nuestro IDE, y nos marcará si la interfaz está correctamente implementada. @FunctionalInterface public interface Calculator { // My abstract method String calculate(int arg1, int arg2); } ","date":"11-03-2019","objectID":"/interfaces-funcionales-java-8/:0:0","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Ejemplos de interfaces funcionales incluidas en Java 8 Java 8 incluye múltiples interfaces funcionales que podemos utilizar para crear expresiones lambda, y que son muy utilizadas en la API de Streams de Java. Podemos encontrar estas interfaces en el paquete java.util.function. Sin entrar en cada una de ellas, a continuación os dejo ejemplos de las interfaces nuevas que se han incluido en la versión de Java 8. ","date":"11-03-2019","objectID":"/interfaces-funcionales-java-8/:1:0","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaces Consumer y BiConsumer\u003cT,U\u003e Las interfaces Consumer y BiConsumer representan una operación que recibe uno y dos valores respectivamente, y no devuelven ningún resultado. @FunctionalInterface public interface Consumer\u003cT\u003e { void accept(T t); default Consumer\u003cT\u003e andThen(Consumer\u003c? super T\u003e after) { Objects.requireNonNull(after); return (T t) -\u003e { accept(t); after.accept(t); }; } } @FunctionalInterface public interface BiConsumer\u003cT,U\u003e { void accept(T t, U u); default BiConsumer\u003cT,U\u003e andThen(BiConsumer\u003c? super T,? super U\u003e after) { Objects.requireNonNull(after); return (T t, U u) -\u003e { accept(t,u); after.accept(t,u); }; } } ","date":"11-03-2019","objectID":"/interfaces-funcionales-java-8/:1:1","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaz Supplier La interfaz Supplier representa un proveedor de resultados, sin parámetros de entrada y con un parámetro de salida. @FunctionalInterface public interface Supplier\u003cT\u003e { T get(); } ","date":"11-03-2019","objectID":"/interfaces-funcionales-java-8/:1:2","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaces Function y BiFunction\u003cT,U\u003e Las interfaces Function y BiFunction representan una función que recibe uno y dos valores respectivamente, y produce un valor como resultado. @FunctionalInterface public interface Function\u003cT,R\u003e { R apply(T t); default \u003cV\u003e Function\u003cV, R\u003e compose(Function\u003c? super V, ? extends T\u003e before) { Objects.requireNonNull(before); return (V v) -\u003e apply(before.apply(v)); } default \u003cV\u003e Function\u003cT, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after) { Objects.requireNonNull(after); return (T t) -\u003e after.apply(apply(t)); } static \u003cT\u003e Function\u003cT, T\u003e identity() { return t -\u003e t; } } @FunctionalInterface public interface BiFunction\u003cT, U, R\u003e { R apply(T t, U u); default \u003cV\u003e BiFunction\u003cT, U, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after) { Objects.requireNonNull(after); return (T t, U u) -\u003e after.apply(apply(t, u)); } } ","date":"11-03-2019","objectID":"/interfaces-funcionales-java-8/:1:3","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaz UnaryOperator La interfaz UnaryOperator representa una operación en la cual se recibe un parámetro de entrada, y se devuelve un valor del mismo tipo como resultado. @FunctionalInterface public interface UnaryOperator\u003cT\u003e extends Function\u003cT, T\u003e { static \u003cT\u003e UnaryOperator\u003cT\u003e identity() { return t -\u003e t; } } ","date":"11-03-2019","objectID":"/interfaces-funcionales-java-8/:1:4","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaz BinaryOperator La interfaz BinaryOperator representa una operación en la cual se reciben dos parámetro de entrada del mismo tipo, y se devuelve un valor del mismo tipo como resultado. @FunctionalInterface public interface BinaryOperator\u003cT\u003e extends BiFunction\u003cT,T,T\u003e { public static \u003cT\u003e BinaryOperator\u003cT\u003e minBy(Comparator\u003c? super T\u003e comparator) { Objects.requireNonNull(comparator); return (a, b) -\u003e comparator.compare(a, b) \u003c= 0 ? a : b; } public static \u003cT\u003e BinaryOperator\u003cT\u003e maxBy(Comparator\u003c? super T\u003e comparator) { Objects.requireNonNull(comparator); return (a, b) -\u003e comparator.compare(a, b) \u003e= 0 ? a : b; } } ","date":"11-03-2019","objectID":"/interfaces-funcionales-java-8/:1:5","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaces Predicate y BiPredicate Las interfaces Predicate y BiPredicate representan funciones que devuelven un booleano como resultado, y reciben uno y dos parámetros de entrada respectivamente. @FunctionalInterface public interface Predicate\u003cT\u003e { boolean test(T t); default Predicate\u003cT\u003e and(Predicate\u003c? super T\u003e other) { Objects.requireNonNull(other); return (t) -\u003e test(t) \u0026\u0026 other.test(t); } default Predicate\u003cT\u003e negate() { return (t) -\u003e !test(t); } default Predicate\u003cT\u003e or(Predicate\u003c? super T\u003e other) { Objects.requireNonNull(other); return (t) -\u003e test(t) || other.test(t); } static \u003cT\u003e Predicate\u003cT\u003e isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -\u003e targetRef.equals(object); } } @FunctionalInterface public interface BiPredicate\u003cT, U\u003e { boolean test(T t, U u); default BiPredicate\u003cT, U\u003e and(BiPredicate\u003c? super T, ? super U\u003e other) { Objects.requireNonNull(other); return (T t, U u) -\u003e test(t, u) \u0026\u0026 other.test(t, u); } default BiPredicate\u003cT, U\u003e negate() { return (T t, U u) -\u003e !test(t, u); } default BiPredicate\u003cT, U\u003e or(BiPredicate\u003c? super T, ? super U\u003e other) { Objects.requireNonNull(other); return (T t, U u) -\u003e test(t, u) || other.test(t, u); } } ","date":"11-03-2019","objectID":"/interfaces-funcionales-java-8/:1:6","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Las expresiones lambda son una de las múltiples funcionalidades nuevas que nos ofrece Java 8. Estas expresiones son parte de los primeros pasos de Java hacia la programación funcional, y su cometido es introducirnos a las funciones anónimas mediante las cuales podemos definir el comportamiento de los objetos, y los datos que encapsulan. ¿En qué consiste la programación funcional? La programación funcional es un paradigma de programación basado en las funciones matemáticas, que especifica que una función que recibe un parámetro X, siempre devolverá un resultado Y. Este paradigma permite definir comportamiento mediante funciones, pudiendo inyectarlo como parámetro de entrada en los objetos, o devolverlo como resultado de otro método. ","date":"03-02-2019","objectID":"/expresiones-lambda-java-8/:0:0","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/expresiones-lambda-java-8/"},{"categories":["java"],"content":"Introducción a las funciones lambda Por tanto, deducimos de lo anterior, que las funciones lambda son la funcionalidad que Java ofrece para facilitar la definición de comportamiento mediante parámetros. Una función lambda consta de los siguientes elementos: Parámetros de entrada Operador lambda Cuerpo del método Ejemplo de expresión lambda El primer elemento de la expresión lambda, los parámetros de entrada se puede definir como: Expresión lambda sin parámetros de entrada () -\u003e System.out.println(\"Hello Lambda World!\") Expresión lambda con un parámetro de entrada simple x -\u003e x + 10 Expresión lambda con múltiples parámetros de entrada (int x, int y) -\u003e { return x + y; } ﻿ Con respecto al cuerpo del método, para los métodos con una única línea de código no es necesario definir las llaves. // Expresión lambda con dos parámetros de entrada sin return definido (String x, String y) -\u003e x.length() - y.length() Mientras que para métodos con varias líneas, las llaves serán obligatorias. // Expresión lambda con varias líneas de código como cuerpo (String x) -\u003e { //Code... return x.length(); }﻿ ","date":"03-02-2019","objectID":"/expresiones-lambda-java-8/:1:0","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/expresiones-lambda-java-8/"},{"categories":["java"],"content":"Referenciando variables externas Las expresiones lambda pueden hacer referencia a variables locales finales, o efectivamente finales dentro de la clase donde se definen. ¿Y qué es eso de variables efectivamente finales? Las variables efectivamente finales son variables que, aunque no se definen explícitamente como finales, cumplen los requisitos para poder serlo. En el siguiente ejemplo podemos ver cómo se utiliza la variable “before” , una variable efectivamente final, dentro de la expresión lambda que filtra los resultados de la lista de ficheros. //Utilizando variables efectivamente finales dentro de funciones lambda void expire(File root, long before) { root.listFiles(File p -\u003e p.lastModified() \u003c= before); } ","date":"03-02-2019","objectID":"/expresiones-lambda-java-8/:1:1","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/expresiones-lambda-java-8/"},{"categories":["java"],"content":"Referencia “this” en las funciones lambda El uso de “this” en las expresiones lambda hace referencia al objeto en el cual se ha definido la expresión. Siguiendo con el ejemplo anterior, se podría definir una variable final en el objeto que encapsula al método “expire”, y utilizar “this” para hacer referencia a dicha variable. //Referenciando a 'this' dentro de una función lambda public final long currentDate = new Date().getTime(); void expire(File root) { root.listFiles(File p -\u003e p.lastModified() \u003c= this.currentDate); } Esto es así debido a que las expresiones lambda no son más que una representación de funciones anónimas, y estas no están asociadas a ninguna clase, por tanto, una función lambda no puede referenciarse a sí misma. ","date":"03-02-2019","objectID":"/expresiones-lambda-java-8/:1:2","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/expresiones-lambda-java-8/"},{"categories":["java"],"content":"Creando nuestra propia expresión lambda con interfaces funcionales Ahora que ya sabemos cómo funcionan las expresiones lambda, podemos empezar a crear las nuestra. Para ello utilizaremos interfaces funcionales. Las interfaces funcionales son aquellas que definen un único método abstracto. Las interfaces funcionales también pueden definir a su vez tantos métodos estáticos y métodos default como sean necesarios. Para crear nuestra interfaz funcional, deberemos utilizar la anotación @FunctionalInterface. @FunctionalInterface public interface Math{ int calculate(int x, int y); } Una vez creada nuestra interfaz funcional, podremos instanciarla utilizando una expresión lambda, tal y como se define a continuación: public class Test{ public static void main(String\\[\\] args){ executeMath(5,3,(x,y)-\u003ex\\*y); } public int executeMath(int x, int y, Math math){ return math.calculate(x, y); } } Si quieres saber más acerca de las interfaces funcionales puedes hacerlo aquí. ","date":"03-02-2019","objectID":"/expresiones-lambda-java-8/:1:3","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/expresiones-lambda-java-8/"},{"categories":null,"content":"Climbing the Engineering Ladder: From Junior Developer to Technical Lead For the Spanish version go here The journey from a junior developer to a Technical Lead is an incredible feat that requires continuous learning, adaptation, and growth. This article aims to provide insights into the necessary technical and soft skills needed at each step of this career ladder, along with recommended reads for each level. The following list of recommended books does not contain any language-specific suggestions, as its objective is to be relevant to developers working with any programming language. The selection aims to cover a broad range of topics to facilitate the growth and development of software engineering professionals at every stage of their careers. Please note that the following list of recommended books and the software engineering ladder are based on my personal opinion. While these suggestions aim to be a helpful guide, they may not work for everyone or cover every possible career path in the software engineering field. I encourage you to use this information as a starting point to create your own ladder, tailored to your unique goals, preferences, and learning style. ","date":"01-01-0001","objectID":"/software-egineering-lather-en/:0:0","tags":null,"title":"","uri":"/software-egineering-lather-en/"},{"categories":null,"content":"Engineering lather ","date":"01-01-0001","objectID":"/software-egineering-lather-en/:1:0","tags":null,"title":"","uri":"/software-egineering-lather-en/"},{"categories":null,"content":"Junior Developer Technical Skills Basic programming language proficiency (e.g., Java, Python, or JavaScript) Familiarity with development tools (e.g., IDEs, version control) Understanding of data structures and algorithms Soft Skills Effective communication Time management Ability to work in a team Books “Clean Code” by Uncle Bob “Clean Architecture” by Uncle Bob ","date":"01-01-0001","objectID":"/software-egineering-lather-en/:1:1","tags":null,"title":"","uri":"/software-egineering-lather-en/"},{"categories":null,"content":"Mid-Level Developer Technical Skills Advanced programming language proficiency Experience with multiple programming paradigms Working knowledge of databases and SQL Familiarity with design patterns and SOLID principles Soft Skills Problem-solving Attention to detail Adaptability Books “Refactoring: Improving the Design of Existing Code” by Martin Fowler “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides “The Pragmatic Programmer: Your Journey to Mastery” by Andrew Hunt and David Thomas ","date":"01-01-0001","objectID":"/software-egineering-lather-en/:1:2","tags":null,"title":"","uri":"/software-egineering-lather-en/"},{"categories":null,"content":"Senior Developer Technical Skills Expertise in multiple programming languages and frameworks Experience with performance optimization Deep understanding of application architecture Security best practices in software development, including secure coding techniques, vulnerability assessments, and understanding common security risks Soft Skills Mentoring and coaching Conflict resolution Advanced problem-solving Books “Domain-Driven Design: Tackling Complexity in the Heart of Software” by Eric Evans “The Art of Computer Programming” (book series) by Donald Knuth “Patterns of Enterprise Application Architecture” by Martin Fowler “Enterprise Integration Patterns” by Gregor Hohpe and Bobby Woolf “Secure by Design: Principles and Patterns for Building Secure Software” by Dan Bergh Johnsson, Daniel Deogun, and Daniel Sawano ","date":"01-01-0001","objectID":"/software-egineering-lather-en/:1:3","tags":null,"title":"","uri":"/software-egineering-lather-en/"},{"categories":null,"content":"Software Architect Technical Skills Broad knowledge of software design patterns and architectural principles Experience with microservices and distributed systems Familiarity with emerging technologies Soft Skills Strategic thinking Collaboration Excellent communication Books “Software Architecture in Practice” by Len Bass, Paul Clements, and Rick Kazman “Building Microservices: Designing Fine-Grained Systems” by Sam Newman “Fundamentals of Software Architecture: An Engineering Approach” by Mark Richards and Neal Ford ","date":"01-01-0001","objectID":"/software-egineering-lather-en/:1:4","tags":null,"title":"","uri":"/software-egineering-lather-en/"},{"categories":null,"content":"Technical Lead Technical Skills Strong understanding of Agile methodologies Expertise in continuous integration and delivery Experience with large-scale system design and architecture Applying different team structures and interaction patterns for better software delivery Soft Skills Leadership and delegation Decision-making Stakeholder management Books “Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems” by Martin Kleppmann “Streaming Systems: The What, Where, When, and How of Large-Scale Data Processing” by Tyler Akidau, Slava Chernyak, and Reuven Lax “The Mythical Man-Month: Essays on Software Engineering” by Frederick P. Brooks Jr. “Peopleware: Productive Projects and Teams” by Tom DeMarco and Timothy Lister “Talking with Tech Leads” by Patrick Kua “Team Topologies: Organizing Business and Technology Teams for Fast Flow” by Matthew Skelton and Manuel Pais ","date":"01-01-0001","objectID":"/software-egineering-lather-en/:1:5","tags":null,"title":"","uri":"/software-egineering-lather-en/"},{"categories":null,"content":"Thought leaders In the field of software engineering and technology, there are many thought leaders who have made significant contributions to the industry. These individuals possess extensive knowledge and expertise in various aspects of software development, architecture, and management. By following their work, you can stay updated with the latest trends, insights, and best practices in the software engineering world. Below is a list of thought leaders whose ideas and experiences can help you grow professionally and stay informed about the ever-evolving landscape of technology. Martin Fowler Chief Scientist at ThoughtWorks, author, and speaker on software architecture and application design. Twitter: @martinfowler Website: https://martinfowler.com/ Robert C. Martin (Uncle Bob) Founder of Clean Coders, author of books like “Clean Code” and “Clean Architecture,” and advocate for agile software development practices. Twitter: @unclebobmartin Website: https://cleancoders.com/ Eric Evans Consultant and author of the book “Domain-Driven Design,” focusing on software design and architecture based on business domains. Twitter: @ericevans0 Website: https://domainlanguage.com/ Kent Beck Programmer and creator of the Extreme Programming (XP) methodology, a pioneer in agile development practices, and the inventor of Test-Driven Development (TDD). Twitter: @KentBeck Website: https://www.kentbeck.com/ Mark Richards Experienced software architect, author of numerous books on software architecture, and frequent speaker at technical conferences. Twitter: @markrichardssa Website: https://www.developertoarchitect.com/ Neal Ford Director, Software Architect, and Meme Wrangler at ThoughtWorks, author of multiple books on software development and architecture, and an international speaker. Twitter: @neal4d Website: https://nealford.com/ Werner Vogels CTO and Vice President of Amazon, responsible for driving growth and innovation at Amazon Web Services (AWS). Twitter: @Werner Website: https://www.allthingsdistributed.com/ Gene Kim Author and DevOps expert, known for his work on “The Phoenix Project” and the DevOps book series. Twitter: @RealGeneKim Website: https://itrevolution.com/ Sam Newman Consultant and author of the book “Building Microservices,” expert in microservices architecture and modern development practices. Twitter: @samnewman Website: https://samnewman.io/ Kelsey Hightower Developer Advocate at Google Cloud Platform, specializing in container technologies and Kubernetes. Twitter: @kelseyhightower Website: https://www.kelseyhightower.com/ Grady Booch Chief Scientist for Software Engineering at IBM Research, co-author of “Object-Oriented Analysis and Design with Applications,” and one of the creators of the Unified Modeling Language (UML). Twitter: @Grady_Booch Jeff Atwood Co-founder of Stack Overflow, a key resource for developers, and author of the “Coding Horror” blog. Twitter: @codinghorror Website: https://blog.codinghorror.com/ Climbing the engineering ladder from a junior developer to a Technical Lead is a challenging and rewarding journey. By honing both technical and soft skills at each step, professionals can navigate this path and achieve success in their careers. While this guide may not cover every possible scenario or work for everyone, I hope it serves as a valuable starting point and inspires you to create a path tailored to your unique goals and aspirations in the software engineering field. ","date":"01-01-0001","objectID":"/software-egineering-lather-en/:2:0","tags":null,"title":"","uri":"/software-egineering-lather-en/"},{"categories":null,"content":"Climbing the Engineering Ladder: From Junior Developer to Technical Lead Para la versión en inglés ve aquí El viaje de un desarrollador junior a un líder técnico es una hazaña increíble que requiere aprendizaje continuo, adaptación y crecimiento. Este artículo tiene como objetivo proporcionar información sobre las habilidades técnicas y blandas necesarias en cada paso de esta escalera profesional, junto con lecturas recomendadas para cada nivel. La siguiente lista de libros recomendados no contiene sugerencias específicas de lenguaje, ya que su objetivo es ser relevante para los desarrolladores que trabajan con cualquier lenguaje de programación. La selección tiene como objetivo cubrir una amplia gama de temas para facilitar el crecimiento y desarrollo de los profesionales de la ingeniería de software en cada etapa de sus carreras. Tenga en cuenta que la siguiente lista de libros recomendados y la escalera de la ingeniería de software se basan en mi opinión personal. Aunque estas sugerencias tienen como objetivo ser una guía útil, es posible que no funcionen para todos o cubran todas las posibles trayectorias profesionales en el campo de la ingeniería de software. Les animo a utilizar esta información como punto de partida para crear su propia escalera, adaptada a sus objetivos, preferencias y estilo de aprendizaje únicos. ","date":"01-01-0001","objectID":"/software-egineering-lather/:0:0","tags":null,"title":"","uri":"/software-egineering-lather/"},{"categories":null,"content":"Engineering lather ","date":"01-01-0001","objectID":"/software-egineering-lather/:1:0","tags":null,"title":"","uri":"/software-egineering-lather/"},{"categories":null,"content":"Junior Developer Skills Técnicas Dominio básico de lenguajes de programación (por ejemplo, Java, Python o JavaScript) Familiaridad con herramientas de desarrollo (por ejemplo, IDEs, control de versiones) Comprensión de estructuras de datos y algoritmos Soft Skills Comunicación efectiva Gestión del tiempo Abilidad para trabajar en grupo Libros “Clean Code” by Uncle Bob “Clean Architecture” by Uncle Bob ","date":"01-01-0001","objectID":"/software-egineering-lather/:1:1","tags":null,"title":"","uri":"/software-egineering-lather/"},{"categories":null,"content":"Mid-Level Developer Skills Técnicas Dominio avanzado de lenguajes de programación Experiencia con múltiples paradigmas de programación Conocimientos prácticos de bases de datos y SQL Familiaridad con patrones de diseño y principios SOLID Soft Skills Resolución de problemas Atención al detalle Adaptabilidad Libros “Refactoring: Improving the Design of Existing Code” by Martin Fowler “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides “The Pragmatic Programmer: Your Journey to Mastery” by Andrew Hunt and David Thomas ","date":"01-01-0001","objectID":"/software-egineering-lather/:1:2","tags":null,"title":"","uri":"/software-egineering-lather/"},{"categories":null,"content":"Senior Developer Skills Técnicas Experiencia en múltiples lenguajes de programación y frameworks Experiencia en optimización del rendimiento Comprensión profunda de la arquitectura de aplicaciones Mejores prácticas de seguridad en el desarrollo de software, incluyendo técnicas de codificación segura, evaluaciones de vulnerabilidad y comprensión de los riesgos de seguridad comunes Soft Skills Mentoring y coaching Resolución de conflictos Resolución avanzada de problemas Libros “Domain-Driven Design: Tackling Complexity in the Heart of Software” by Eric Evans “The Art of Computer Programming” (book series) by Donald Knuth “Patterns of Enterprise Application Architecture” by Martin Fowler “Enterprise Integration Patterns” by Gregor Hohpe and Bobby Woolf “Secure by Design: Principles and Patterns for Building Secure Software” by Dan Bergh Johnsson, Daniel Deogun, and Daniel Sawano ","date":"01-01-0001","objectID":"/software-egineering-lather/:1:3","tags":null,"title":"","uri":"/software-egineering-lather/"},{"categories":null,"content":"Software Architect Skills Técnicas Amplio conocimiento de patrones de diseño de software y principios arquitectónicos Experiencia con microservicios y sistemas distribuidos Familiaridad con tecnologías emergentes Soft Skills Pensamiento estratégico Colaboración Excelente comunicación Libros “Software Architecture in Practice” by Len Bass, Paul Clements, and Rick Kazman “Building Microservices: Designing Fine-Grained Systems” by Sam Newman “Fundamentals of Software Architecture: An Engineering Approach” by Mark Richards and Neal Ford ","date":"01-01-0001","objectID":"/software-egineering-lather/:1:4","tags":null,"title":"","uri":"/software-egineering-lather/"},{"categories":null,"content":"Technical Lead Skills Técnicas Sólida comprensión de las metodologías Ágiles Experiencia en integración continua y entrega Experiencia en diseño y arquitectura de sistemas a gran escala Aplicación de diferentes estructuras de equipo y patrones de interacción para una mejor entrega de software Soft Skills Liderazgo y delegación Toma de decisiones Gestión de interesados Libros “Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems” by Martin Kleppmann “Streaming Systems: The What, Where, When, and How of Large-Scale Data Processing” by Tyler Akidau, Slava Chernyak, and Reuven Lax “The Mythical Man-Month: Essays on Software Engineering” by Frederick P. Brooks Jr. “Peopleware: Productive Projects and Teams” by Tom DeMarco and Timothy Lister “Talking with Tech Leads” by Patrick Kua “Team Topologies: Organizing Business and Technology Teams for Fast Flow” by Matthew Skelton and Manuel Pais ","date":"01-01-0001","objectID":"/software-egineering-lather/:1:5","tags":null,"title":"","uri":"/software-egineering-lather/"},{"categories":null,"content":"Líderes de opinión En el campo de la ingeniería de software y la tecnología, existen muchos líderes de opinión que han realizado contribuciones significativas a la industria. Estas personas poseen amplios conocimientos y experiencia en varios aspectos del desarrollo, la arquitectura y la gestión de software. Siguiendo su trabajo, puedes mantenerte actualizado con las últimas tendencias, ideas y mejores prácticas en el mundo de la ingeniería de software. A continuación, se presenta una lista de líderes de opinión cuyas ideas y experiencias pueden ayudarte a crecer profesionalmente y mantenerte informado sobre el siempre cambiante panorama de la tecnología. Martin Fowler Consultor principal en ThoughtWorks, autor y conferencista en temas de arquitectura de software y diseño de aplicaciones. Twitter: @martinfowler Website: https://martinfowler.com/ Robert C. Martin (Uncle Bob) Fundador de Clean Coders, autor de libros como “Clean Code” y “Clean Architecture”, y promotor de prácticas de desarrollo de software ágiles. Twitter: @unclebobmartin Website: https://cleancoders.com/ Eric Evans Consultor y autor del libro “Domain-Driven Design”, que se centra en el diseño y la arquitectura de software en función de los dominios empresariales. Twitter: @ericevans0 Website: https://domainlanguage.com/ Kent Beck Programador y creador de la metodología Extreme Programming (XP), uno de los pioneros en las prácticas de desarrollo ágil y creador del concepto de Test-Driven Development (TDD). Twitter: @KentBeck Website: https://www.kentbeck.com/ Mark Richards Experienced software architect, author of numerous Libros on software architecture, and frequent speaker at technical conferences. Twitter: @markrichardssa Website: https://www.developertoarchitect.com/ Neal Ford Director, Software Architect, and Meme Wrangler at ThoughtWorks, author of multiple Libros on software development and architecture, and an international speaker. Twitter: @neal4d Website: https://nealford.com/ Werner Vogels CTO y vicepresidente de Amazon, responsable de dirigir el crecimiento y la innovación en Amazon Web Services (AWS). Twitter: @Werner Website: https://www.allthingsdistributed.com/ Gene Kim Autor y experto en DevOps, conocido por su trabajo en el libro “The Phoenix Project” y la serie de libros sobre DevOps. Twitter: @RealGeneKim Website: https://itrevolution.com/ Sam Newman Consultor y autor del libro “Building Microservices”, experto en arquitectura de microservicios y prácticas de desarrollo modernas. Twitter: @samnewman Website: https://samnewman.io/ Kelsey Hightower Desarrollador y defensor de la comunidad en Google Cloud Platform, especializado en tecnologías de contenedores y Kubernetes. Twitter: @kelseyhightower Website: https://www.kelseyhightower.com/ Grady Booch Científico jefe de software en IBM Research, coautor del libro “Object-Oriented Analysis and Design with Applications” y uno de los creadores del Unified Modeling Language (UML). Twitter: @Grady_Booch Jeff Atwood Cofundador de Stack Overflow, un recurso clave para los desarrolladores, y autor del blog “Coding Horror”. Twitter: @codinghorror Website: https://blog.codinghorror.com/ Escalar la escalera de la ingeniería desde un desarrollador junior hasta un Líder Técnico es un camino desafiante y gratificante. Al perfeccionar tanto las habilidades técnicas como las habilidades blandas en cada paso, los profesionales pueden navegar por este camino y lograr el éxito en sus carreras. Si bien esta guía puede no cubrir todos los posibles escenarios o no ser útil para todos, espero que sirva como un punto de partida valioso e inspire a crear un camino adaptado a sus objetivos y aspiraciones únicas en el campo de la ingeniería de software. ","date":"01-01-0001","objectID":"/software-egineering-lather/:2:0","tags":null,"title":"","uri":"/software-egineering-lather/"},{"categories":null,"content":"Mi nombre es David Fuentes, actualmente trabajo en Intelygenz como Tech Lead y Software Architect. ","date":"01-01-0001","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Educación Estudios Año Máster en Inteligencia Artificial 2020 - Actual Máster en Ciberseguridad, con especialización en seguridad en servicios y aplicaciones 2017 - 2018 Grado en Ingeniería Informática 2012 - 1016 ","date":"01-01-0001","objectID":"/about/:1:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Experiencia Posición Empresa Año Lead Technical Architect Intelygenz - MetTel 2022 - Actual Technical Lead Intelygenz - Inditex 2020 - 2022 Senior Software Architect Intelygenz - Inditex 2019 - 2020 Senior Software Architect \u0026 DevOps Minsait by Indra 2018 - 2019 R\u0026D and Architecture Lead Almis Informática Financiera 2017 - 2018 Spring / Java Developer Almis Informática Financiera 2015 - 2018 Java \u0026 Web Developer Alecop S. Coop. 2012 - 1015 ","date":"01-01-0001","objectID":"/about/:2:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Contacto Si quieres contactar conmigo, mándame un correo! ","date":"01-01-0001","objectID":"/about/:3:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Si quieres contactar conmigo, mándame un correo! ","date":"01-01-0001","objectID":"/contact/:0:0","tags":null,"title":"Contact me","uri":"/contact/"},{"categories":null,"content":"Galería de imágenes que he generado con Stable Diffusion. Abstract fantasy scene C3PO Daenerys Targaryen Disney scene Fantasy forest Sky scrappers by Liam Wong Sky scrappers by Mike Winkelmann Star Wars portrait Star Wars trooper The Hulk The Moon by Jessica Rossier The Moon by Justin Gerard 2 The Moon by Justin Gerard 3 The Moon by Justin Gerard The Moon by dan mumford Valhalla Viking portrait Wonder Woman Silhouette ","date":"01-01-0001","objectID":"/stable-diffusion/:0:0","tags":null,"title":"Stable diffusion gallery","uri":"/stable-diffusion/"}]