[{"categories":["software-architecture","communication-protocols"],"content":"Protocol Buffers es el mecanismo diseñado por Google para serializar y deserializar datos estructurados. Google decidió crear este mecanismo como alternativa a XML o JSON, en busca de una forma más eficiente de serializar y deserializar los datos. Protocol Buffer o Protobuf, es agnóstico del lenguaje y la plataforma utilizados para implementarlo, y está creado para ser extensible, lo que facilita la evolución y mantenimiento de este el la vida de un proyecto. Sin embargo, una de las desventajas con respecto a XML o JSON, es que el número de lenguajes en el que podemos utilizarlo está limitado a los lenguajes que el compilador tiene implementados. Su funcionamiento es sencillo, se define un fichero ‘.proto’ que contiene el esquema con el que queremos que los datos sean estructurados, y mediante el compilador que nos ofrece el equipo de Protocol Buffers para los distintos lenguajes, generamos las clases necesarias para implementar dicho esquema, y que nos permite serializar y deserializar mensajes de forma nativa. La sintaxis de Protocol Buffers es sencilla, empecemos por el ejemplo más simple, definir un mensaje. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:0:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Elemento Message ‘message’ es el elemento que nos permite definir la estructura de datos que utilizar en nuestras comunicaciones. Un fichero ‘.proto’ puede tener uno o varios elementos ‘message’, además de enumerados y comentarios como veremos más adelante. syntax = “proto3”; message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Corpus corpus = 4; } La primera línea del ejemplo define qué sintaxis vamos a utilizar, en este caso estamos definiendo que utilizaremos la sintaxis de la versión v3. Si omitimos esta línea, el compilador asumirá que estamos utilizando la versión v2. La estructura que le sigue define el esquema que queremos que tengan nuestro elemento ‘message’. Para ello utilizamos la palabra reservada ‘message’ para definir que queremos crear una estructura de datos que compondrá un mensaje, y definimos el nombre de la estructura de datos como ‘SearchRequest’. Una vez señalado el tipo de elemento que estamos definiendo, incluimos los datos que va a contener con el formato que veremos a continuación. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:1:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Numeración Los campos de las estructuras de datos están numerados. Esta numeración se utiliza para identificar los campos una vez el mensaje está serializado, y no deberían cambiar una vez la estructura de datos está en uso, ya que puede derivar en errores de deserialización. La numeración debe ser única, es decir, no puede haber índices repetidos, ya que de lo contrario el compilador nos lanzará un error. El índice de datos que podemos utilizar va desde el 1 al 229 - 1, estando reservados para uso interno de Protocol Buffers los índices del 19000 al 19999. Tal y como se especifica en la documentación, los índices del 1 al 15 ocupan un byte de espacio, mientras que los índices del 16 al 2047 ocupan 2 bytes, por lo que deberíamos reservar los primeros 15 índices para campos que se utilizan muy frecuentemente en la estructura de datos. Esto hará que las los procesos de serialización y deserialización sean más eficientes. Esto significa que, pensando en la evolución que pueda tener el proto, deberíamos dejar cierto espacio de índices reservado para futuros campos a los que se les pueda llegar a dar mucho uso, utilizando para campos menos frecuentes los índices del 16 en adelante. Todos los campos de un mensaje pueden anotarse con las palabras clave ‘singular’ y ‘repeated’, que definen que el campo puede aparecer una o varias veces, respectivamente. A su vez, cada uno de los campos de la estructura de datos deberá definir el tipo, tal y como veremos a continuación. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:1:1","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Tipos de campos Los datos de una estructura de datos pueden ser de uno de los siguientes tipos: Tipo en '.proto'Tipo en JavaValores por defectofloatfloat0int32, uint32, sint32, sfixed32int0int64, uint64, sint64, sfixed64long0boolboolfalsestringStringString vacíoBytesByteStringByteString vacío Para saber más acerca de los tipos de datos y su codificación, podéis acceder a la documentación oficial. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:1:2","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Campos reservados En los campos de un mensaje, al igual que en los enumerados, los índices se pueden reservar utilizando la siguiente sintaxis. message Foo { reserved 2, 15, 9 to 11; reserved “foo”, “bar”; } Podemos reservar tanto campos numéricos como textos, pero nunca mezclandolos en la misma línea. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:1:3","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Estructuras de datos como campos Las estructuras de datos pueden contener, a su vez, otras estructuras de datos: message SearchResponse { repeated Result results = 1; } message Result { string url = 1; string title = 2; repeated string snippets = 3; } Para ello, podemos definir la estructura que vamos a utilizar como campo, y una vez definida, añadirla a otra estructura de datos, como en el ejemplo anterior. Además, vemos como en el ejemplo se define el campo con la palabra ‘repeated’. Esta opción permite definir el campo anotado como un array de datos, y se puede utilizar con cualquier tipo definido en los apartados anteriores. Estructuras anidadas Siguiendo la misma lógica anterior, también podemos definir estructuras anidadas dentro de otras estructuras de datos, sin la necesidad de implementar las estructuras por separado, fuera del propio ‘message’ contenedor: message SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1; } Uno de los aspectos que diferencia una estructura anidada, es que si queremos hacer uso de esta en otras estructuras, deberemos definirla de la siguiente manera: message SomeOtherMessage { SearchResponse.Result result = 1; } Se pueden anidar tantas estructuras de datos como se quieran, Protocol Buffers no define ningún límite en la anidación. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:1:4","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Importando ‘.proto’s Protocol Buffers nos permite reutilizar los esquemas definidos mediante la importación de ‘.proto’s. Para realizar una importación, solo tendremos que definir la siguiente línea en la cabecera del ‘.proto’ actual, y una vez importado, podremos utilizar los message definidos: import “myproject/other_protos.proto”; ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:2:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Comentarios en ficheros ‘.proto’ Los ficheros ‘.proto’ se pueden comentar con la sintaxis habitual de Java, utilizando // y /* … */. Estos comentarios se convertirán a comentarios del lenguaje seleccionado, documentando las clases generadas para facilitar su utilización. /* SearchRequest represents a search query, with pagination options to indicate which results to include in the response. */ message SearchRequest { string query = 1; int32 page_number = 2; // Which page number do we want? int32 result_per_page = 3; // Number of results to return per page. } ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:3:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Enumerados Los campos definidos en un ‘message’ también pueden ser de tipo enumerados, que podemos crear tanto en la propia estructura de datos, como fuera de estas, como un elemento separado. Un ejemplo de definición de los enumerados es la siguiente: enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Al igual que los campos de una estructura de datos, los campos de los enumerados también están numerados, por los mismos motivos, pero con algunas diferencias. La diferencia más relevante es que un enumerado siempre deberá tener un elemento con la numeración 0. Esto es debido a que este valor se utilizará como valor por defecto, además de utilizarse para la retrocompatibilidad con la versión 2 de Protocol Buffers. La problemática más habitual en enumerados y elementos ‘message’ es la retrocompatibilidad de estos en las actualizaciones que eliminan uno o varios campos. Esto es debido a que al eliminar un campo, liberamos la numeración de este para poder ser utilizada por otro campo distinto, y esto puede llegar a causar conflictos de serialización entre versiones. Para darle una solución, Protocol Buffers permite reservar el uso de ciertos valores mediante la palabra reservada ‘reserved’, con la cual podemos definir qué valores, ya sean numéricos o strings, queremos reservar para que no puedan ser utilizados en futuras actualizaciones. De esta manera restringimos los valores que podemos utilizar y aseguramos la retrocompatibilidad entre versiones. enum Foo { reserved 2, 15, 9 to 11, 40 to max; reserved “FOO”, “BAR”; } ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:4:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Aliases Los enumerados tienen otra particularidad, y es que permiten utilizar aliases. Los aliases son valores con el mismo índice que nos devolverán el mismo valor una vez implementados, pero manteniendo distinto texto. Para utilizarlos tenemos que habilitarlos en el propio enumerado de la siguiente manera, de lo contrario el compilador nos lanzará un error al detectar numeración duplicada: enum EnumAllowingAlias { option allow_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 1; } Una vez habilitados, podremos definir varios elementos con la misma numeración, que se podrán utilizar como aliases para definir un mismo valor. En el caso anterior, los campos STARTED, y RUNNING tienen el mismo valor en el enumerado. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:4:1","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Otros comandos Además de los tipos básicos, Protocol Buffers nos ofrece ciertos comandos más complejos con los que podemos añadir cierta lógica y condicionamiento a los ‘message’. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:5:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"oneOf La palabra reservada ‘oneOf’ se utiliza para definir que, de un conjunto de campos, solo uno de ellos debe ser definido al mismo tiempo. Cuando se define un valor para uno de los campos dentro de esta estructura, se borra el valor del resto de campos que contiene. message SampleMessage { oneof test_oneof { string name = 4; SubMessage sub_message = 9; } } Para saber cual de los campos ha sido el que se ha definido, Protocol Buffers implementado dos métodos que nos dan esta información en la compilación de las clases, el método case() y el método WhichOneOf(). Una de las limitaciones de esta funcionalidad, es que no se pueden utilizar campos de tipo repeated. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:5:1","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Maps Protocol Buffers permite definir mapas de datos mediante la siguiente sintaxis: map\u003ckey_type, value_type\u003e map_field = N; Donde: Key_type: Puede ser cualquier tipo de entero o string. Value_type: Puede ser cualquier tipo, excepto otro mapa. Por otro lado, los campos de un mapa no pueden ser de tipo ‘repeated’, y el mapa no tiene porque guardar el orden original en el que se insertaron los datos. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:5:2","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Servicios De querer utilizar los protos definidos en un sistema de RPC, Protocol Buffers permite definir un servicio que especifica el contrato que se deberá cumplir para poder utilizar el mensaje con el protocolo RPC. service SearchService { rpc Search (SearchRequest) returns (SearchResponse); } La implementación del protocolo de comunicaciones RPC más común a utilizar con Protocol Buffers es gRPC, un sistema RPC agnóstico de lenguaje y plataforma, también creado por Google, que permite generar el código necesario para la comunicación RPC directamente en la compilación de los ficheros ‘.proto’. Si somos muy puristas, podemos definir nuestra propia implementación para la comunicación RPC siguiendo esta guía. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:5:3","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Mapeo JSON Protocol Buffers nos permite mapear nuestros datos al formato JSON para facilitar la exportación e importación de datos, además de facilitar la integración con servicios externos. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:5:4","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Opciones dentro del Proto Además de la definición de la sintaxis, existen otras opciones disponibles para los ficheros ‘.proto’: Option java_package: define el package en el que se generarán las clases compiladas. Option java_multiple_files: Permite que las clases se generen en clases separadas dentro del package definido, en vez de generarse en clases abstractas dentro de una clase principal. Option java_outer_classname: Nombre de la clase principal que contendrá, si no se define lo contrario, todas las clases generadas a partir del fichero de ‘.proto’. Si no se define ningun valor, este se recogerá de la conversión a Camel Case del nombre del fichero de ‘.proto’. Option optimize_for: Permite definir la optimización del código generado para: La velocidad (SPEED), el tamaña de código (CODE_SIZE) o el uso de la librería Lite de Protocol Buffers (LITE_RUNTIME). Int32 old_field = 4 [deprecated=true]: Marca como deprecado el campo marcado. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:5:5","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["software-architecture","communication-protocols"],"content":"Compilando el ‘.proto’ y generando código Para generar el código a partir del fichero ‘.proto’, deberemos utilizar la opción pertinente para cada lenguaje en el compilador. El comando para la compilación y generación de código es el siguiente, en el que podemos ver los distintos lenguajes soportados: protoc –proto_path=IMPORT_PATH –cpp_out=DST_DIR –java_out=DST_DIR –python_out=DST_DIR –go_out=DST_DIR –ruby_out=DST_DIR –objc_out=DST_DIR –csharp_out=DST_DIR path/to/file.proto Donde: IMPORT_PATH: Define el path donde el compilador buscará los ficheros ‘.proto’. *_output: Define los paths de salida para el código generado para los múltiples lenguajes soportados por el compilador. ","date":"15-05-2019","objectID":"/blog/introduccion-a-protocol-buffers/:6:0","tags":["protocol-buffers"],"title":"Introducción a Protocol Buffers","uri":"/blog/introduccion-a-protocol-buffers/"},{"categories":["java"],"content":"Junto con las expresiones lambda, los Streams son una de las funcionalidades más relevantes de Java 8, y trae consigo una nueva forma de trabajar. Mediante una capa de abstracción, los Streams nos permiten definir la lógica de negocio como un conjunto de funciones que se ejecutan de forma anidada. De este modo, podemos trabajar con colecciones utilizando el paradigma de programación funcional, que nos permite definir las funciones a ejecutar de una forma mucho más clara y, en cierto modo, lo más parecida posible a como lo haríamos las personas en una situación real. El siguiente código muestra la lógica de un programa que filtra una lista de enteros, y devuelve el valor más pequeño de la lista, sin tener en cuenta los números pares: public static void main(String[] args) { List integers = Arrays.asList(3, 12, 21, 4, 2, 7, 5); Integer min = integers.get(0); for (Integer next : integers) { if (next % 2 == 0) continue; if (next \u003c min) { min = next; } } System.out.println(min); } Ahora veremos cómo se escribiría este mismo código utilizando Streams. public static void main(String[] args) { List integers = Arrays.asList(3, 12, 21, 4, 2, 7, 5); Optional\u003cInteger\u003e min = integers.stream() .filter(integer -\u003e integer % 2 != 0) .min(Integer::compareTo); System.out.println(min.get()); } Como se puede observar, el código queda mucho más claro, ya que se organiza por funciones anidadas, que se ejecutan como un flujo de trabajo, generando nuevos _Stream_s a medida que avanzan en la cadena de ejecución. ","date":"03-04-2019","objectID":"/blog/streams-java-8/:0:0","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/blog/streams-java-8/"},{"categories":["java"],"content":"Elementos de un Stream Como ya he comentado, los Streams son abstracciones que nos permiten definir operaciones agregadas sobre una fuente de datos utilizando funciones. Los Streams se componen de tres partes: La fuente de datos Las operaciones intermedias La operación terminal // Fuente de datos: 1 Stream.of(“Some, Comma, Separated, Values”) // Operaciones intermedias: 0 -\u003e N .flatMap(string -\u003e Stream.of(string.split(\",\"))) .map(string -\u003e string.trim()) //Operación terminal: 1 .forEach(System.out::println); ","date":"03-04-2019","objectID":"/blog/streams-java-8/:1:0","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/blog/streams-java-8/"},{"categories":["java"],"content":"Fuentes de datos La fuente de datos consiste en una colección de datos que pueden ser tratados como una cadena de valores. Java ofrece distintas fuentes de Streams para ciertas clases: Collection.stream()JarFile.stream() ZipFile.stream()Collection.parallelStream()BufferedReader.lines()Arrays.stream()Pattern.splitAsStream()Files.find(Path, BiPredicate, FileVisitOption)CharSequence.chars()Files.list(Path)CharSequence.codePoints()Files.lines(Path)BitSet.stream()Files.walk(Path, FileVisitOption)Random().Ints() Random().Doubles() Random().Longs() También podemos utilizar métodos estáticos para crear Streams a partir de datos existentes: Stream.concat(Stream, Stream)Concatena dos Streams existentes y devuelve el Stream resultante.Stream.of(T… values)Crea un Stream a partir de los valores de entrada.IntStream.range(int, int)Stream de enteros entre los dos valores dados como parámetros de entrada.Stream.generate(IntSuppliert)Stream generado por un proveedor de resultados. Ejemplo: Stream.generate(new Random()::nextInt) Stream.iterate(int, IntUnaryOperator)El método Iterate() utiliza un valor como semilla para generar el Stream. ","date":"03-04-2019","objectID":"/blog/streams-java-8/:1:1","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/blog/streams-java-8/"},{"categories":["java"],"content":"Operaciones intermedias Las operaciones intermedias son operaciones que se aplican sobre la fuente de Stream definida. Estas operaciones no se ejecutan hasta que no se incluye una operación terminal en la secuencia de operaciones, que es la que causa que la cadena de operaciones se ejecute. La mayoría de las operaciones intermedias reciben un parámetro (interfaz funcional) que define su comportamiento, generalmente utilizando expresiones lambda. Como resultado, todas las operaciones intermedias devuelven un Stream, para que se puedan seguir concatenando operaciones. El comportamiento definido para estas operaciones debe ser no interferentes sobre la ejecución del Stream, esto significa que la ejecución de la operación actual no debe afectar al resto. También deben ser stateless, es decir, debe tratar cada ejecución independientemente, sin relacionar las ejecuciones entre sí. Estos dos patrones de comportamiento permite que un Stream pueda ser ejecutado de forma secuencial o paralela, sin necesidad de modificaciones, y definiendo su comportamiento en tiempo de ejecución. Existen múltiples operaciones intermedias, a continuación veremos las más frecuentes. Operaciones de filtrado y mapeado distinct()Devuelve un Stream sin elementos duplicados.filter(Predicate)Devuelve un Stream únicamente con los elementos que devuelven true al Predicate definido.map(Function)Devuelve un Stream en el cual se le aplica la función definida a cada uno de los elementos del Stream original.mapToInt(Function) Devuelve un Stream de enteros aplicando la función definida a cada uno de los elementos del Stream original.mapToDouble(Function)Devuelve un Stream de Doubles aplicando la función definida a cada uno de los elementos del Stream original.mapToLong(Function)Devuelve un Stream de Longs aplicando la función definida a cada uno de los elementos del Stream original. Además de las operaciones anteriores, existe un tipo de mapeado que devuelve múltiples resultados por cada valor procesado, este tipo de mapeado se denomina FlatMap. En la siguiente imagen se puede distinguir fácilmente la diferencia entre los Maps y los FlatMaps. Un ejemplo práctico sería el siguiente, en el cual creamos un Stream a partir de un String, haciendo un split por la coma utilizando el método FlatMap. Este método nos genera un nuevo Stream a partir de cada uno de los resultados obtenidos que podemos seguir procesando. public static void main(String[] args) { Stream.of(\"Some, Comma, Separated, Values\") .flatMap(string -\u003e Stream.of(string.split(\",\"))) .map(string -\u003e string.trim()) .forEach(System.out::println); } Operaciones de restricción de tamaño skip(Long n)Devuelve un Stream que ignora los primeros n elementos de la fuente de datos.limit(Long n)Devuelve un Stream que contiene los primeros n elementos de la fuente de datos. Operaciones de ordenación y desordenación sorted()Devuelve un Stream ordenado por ordenación natural. La ordenación natural es el orden el que un objeto primitivo debe ordenarse en una colección.sorter(Comparator)Devuelve un Stream ordenado mediante el Comparator recibido como parámetro de entrada.Unordered()Devuelve un Stream desordenado. Puede mejorar la eficiencia de otras operaciones como distinct() o groupingBy(). Observando los elementos de un Stream peek(Consumer)Devuelve un Stream idéntico al Stream del data source, aplicando la acción del Consumer a cada uno de los elementos. El método peek() no debería modificar los elementos del Stream. Generalmente utilizado para debugear. ","date":"03-04-2019","objectID":"/blog/streams-java-8/:1:2","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/blog/streams-java-8/"},{"categories":["java"],"content":"Operaciones terminales Las operaciones terminales son las que terminan el pipeline de operaciones de un Stream y activan su ejecución. Un Stream solo se ejecutará cuando el pipeline incluya una de estas operaciones. Al interpretar cómo se debe ejecutar la secuencia de operaciones del Stream, se aplican procesos de optimización para mergear o rechazar operaciones innecesarias, eliminar operaciones redundantes o ejecutar el stream en paralelo si fuera necesario. Las operaciones terminales generan un valor o una acción como resultado, esto hace que este tipo de operaciones cierren la cadena de ejecución, ya que no devuelve un Stream. Las operaciones terminales más comunes son las siguientes: Operaciones condicionales Optional\u003cT\u003e findFirst(Predicate)Devuelve el primer elemento del Stream que coincida con la condición del predicado, o un Optional vacío si no se cumple la condición.Optional\u003cT\u003e findAny(Predicate)Devuelve un elemento aleatorio del Stream que coincida con la condición del predicado, o un Optional vacío si no se cumple la condición. Pensado para ofrecer un mayor rendimiento en operaciones paralelas.Boolean allMatch(Predicate)Devuelve true si la condición del predicado se cumple para todos los elementos del Stream, false para el resto de casos.Boolean anyMatch(Predicate)Devuelve true si la condición del predicado se cumple para cualquier elemento del Stream, false para el resto de casos.Boolean noneMatch(Predicate)Devuelve true si la condición del predicado no se cumple para ningúnelemento del Stream, false para el resto de casos. Operaciones que devuelve colecciones collect(Collector)Devuelve el Stream en forma de colección del tipo que definamos. Podemos utilizar la clase de utilidad Collectors, que nos ofrece varias implementaciones de la interfaz Collector. toArray()Devuelve los elementos del Stream a modo de Array. Operaciones que devuelve resultados numéricos count()Devuelve un entero con el número de elementos que contiene el Stream.max(Comparator)Devuelve el valor más grande que contenga el Stream. Podemos definir el comparador que vamos a utilizar.min(Comparator)Devuelve el valor más pequeño que contenga el Stream. Podemos definir el comparador que vamos a utilizar.average()Devuelve la media aritmética del Stream.sum()Devuelve la suma de los elementos del Stream. Operaciones de iteración forEach(Consumer)Ejecuta la acción definida en el consumidor a cada elemento del Stream.forEach(Consumer)Realiza la misma acción que forEach() pero asegurando que el orden de ejecución se mantiene cuando se usa con Streams ejecutados de forma paralela. Operaciones de reducción reduce(BinaryOperator accumulator)Realiza una reducción en el Stream utilizando un BinaryOperator. El BinaryOperator recibe dos parámetros de entrada: el primero es el valor ya reducido, y el segundo es el valor a reducir. Esta acción se aplica a cada uno de los elementos del Stream. ","date":"03-04-2019","objectID":"/blog/streams-java-8/:1:3","tags":["functional-programming","streams"],"title":"Java 8: Streams","uri":"/blog/streams-java-8/"},{"categories":["java"],"content":"Hasta Java 8, las interfaces únicamente podían implementar métodos públicos y abstractos por defecto. En la versión de Java 8 esto ha cambiado, se ha extendido la funcionalidad de las interfaces, de modo que puedan albergar métodos estáticos y métodos default que nos permiten definir lógica de negocio dentro de las propias interfaces. ","date":"25-03-2019","objectID":"/blog/novedades-en-interfaces-java-8/:0:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/blog/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"Métodos default El objetivo que se persigue con este tipo de funcionalidad es dar a las interfaces la capacidad de definir un comportamiento estándar para toda clase que las implemente, pudiendo especializar cualquiera de los métodos definidos sobreescribiéndolos en la propia implementación de la clase. Esto evita las duplicaciones de código en clases que implementen el mismo comportamiento estándar. Además, facilita la extensión de nuestra arquitectura (Open/Closed principle), ya que al definir una implementación por defecto para los nuevos método en la interfaz, no estamos obligados a definirlos en cada una de las clases que la implementen, ofreciendo así cierta retrocompatibilidad. El siguiente ejemplo define una interfaz con un método default, y muestra cómo utilizarlo en una clase que lo implemente. public interface MyInterface { // Default method for getting \"Hello World\" String default String defaultHelloWorld(){ return \"Default Hello World!\"; } } class MyClass implements MyInterface { public static void main(String\\[\\] args) { MyClass myClass = new MyClass(); System.out.println(\"Default: \" + myClass.defaultHelloWorld()); } } Y obtenemos los resultados esperados. //Result Default: Default Hello World! ","date":"25-03-2019","objectID":"/blog/novedades-en-interfaces-java-8/:1:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/blog/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"Métodos estáticos Los métodos estáticos siguen la misma idea que los default, permitir definir lógica de negocio dentro de nuestra interfaz, y evitar así duplicados de código innecesarios. Y como he mencionado anteriormente, también ayudan a que nuestro código sea fácilmente extensible y mantenible. La diferencia con respecto a los métodos default, es que al ser estáticos, los métodos que definamos no serán sobreescribibles en las clases que implementen la interfaz. public interface MyInterface{ // Static method for getting \"Hello World\" String static String staticDefaultHelloWorld(){ return \"Static Hello World!\"; } } class MyClass implements MyInterface { public static void main(String\\[\\] args) { MyClass myClass = new MyClass(); System.out.println(\"Static: \" + MyClass.staticDefaultHelloWorld()); } } Y obtenemos los resultados. //Result Static: Static Hello World! Pero como siempre, con las nuevas funcionalidades, también se plantean diversas casuísticas que pueden llevarnos a confusión. ","date":"25-03-2019","objectID":"/blog/novedades-en-interfaces-java-8/:2:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/blog/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"Implementar múltiples interfaces con las mismas funciones default Utilizando los métodos default podría darse el caso de tener una clase que implemente varias interfaces, que contengan un mismo método. No hay jerarquía entre ambas interfaces, por lo que el compilador no sabrá cuál de las dos seleccionar a la hora de invocar el método. public interface Interface1 { default String getHelloWorldStr(){ return “Hello world from Interface 1”; } } public interface Interface2 { default String getHelloWorldStr(){ return “Hello world from Interface 2”; } } Por tanto, la clase que implemente ambas interfaces se verá obligada a sobrescribir el método getHelloWorld por el compilador, para evitar errores de compilación. public class HelloWorldClass implements Interface1, Interface2 { @Override public String getHelloWorldStr() { return “Hello World from HelloWorldClass”; } } ","date":"25-03-2019","objectID":"/blog/novedades-en-interfaces-java-8/:3:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/blog/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"El problema del diamante Existe un caso, muy parecido al anterior, llamado problema del diamante. Este problema consiste en la ambigüedad que surge como consecuencia de la herencia múltiple, y que provoca que el método que hay que invocar no pueda ser extraído mediante las reglas de resolución de conflictos de las interfaces de Java. Este es un problema común entre los lenguajes que permiten la herencia múltiple, y su nombre viene de la forma que toma la definición de esta arquitectura. Problema del diamante Imaginemos un escenario en el cual existen dos interfaces, Interface1 e Interface2, que extienden de una tercera interfaz Interface0. interface Interface0 { default String getHelloWorldStr(){ return “Hello world from Interface 0”; } } interface Interface1 extends Interface0{ default String getHelloWorldStr(){ return “Hello world from Interface 1”; } } interface Interface2 extends Interface0{ default String getHelloWorldStr(){ return “Hello world from Interface 2”; } } Como se puede observar en el código anterior, las interfaces Interface1, e Interface2 quedan al mismo nivel jerárquico, mientras que Interface0 queda por debajo de estas. Esto genera un problema, ya que al no existir una cadena jerárquica, el compilador no es capaz de inferir el método a utilizar, y nos forzará a reescribirlo explícitamente en nuestra clase. public class MyClass implements Interface1, Interface2 { // Overwritten method from both Interface1 and Interface2 interfaces. @Override public String getHelloWorldStr() { return \"Hello World from MyClass\"; } public static void main(String\\[\\] args) { MyClass myClass = new MyClass(); System.out.println(myClass.getHelloWorldStr()); } } Obteniendo como resultado el de la implementación de la clase. //Result Hello World from MyClass ","date":"25-03-2019","objectID":"/blog/novedades-en-interfaces-java-8/:4:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/blog/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"Reglas para la selección de métodos default Como he comentado antes, existen ciertas reglas que el compilador de Java aplica cuando necesita seleccionar la implementación de un método definido en múltiples interfaces, ya que la herencia múltiple necesita de este tipo de soluciones. El compilador necesita una jerarquía de prioridades que aplicar cuando existen múltiples instancias del mismo método al que se hace referencia desde distintas interfaces y clases. Por este motivo, el compilador aplica una serie de reglas para aplicar dicha jerarquía: La implementación de las clases o superclases siempre tienen prioridad. public interface Interface1 { default String getHelloWorldStr(){ return “Hello world from Interface 1”; } } class HelloWorldClass implements Interface1{ @Override public String getHelloWorldStr() { return “Hello World from HelloWorldClass”; } public static void main(String\\[\\] args) { HelloWorldClass helloWorldClass = new HelloWorldClass (); System.out.println(helloWorldClass.getHelloWorldStr()); } } En este caso el resultado sería el definido en la implementación de la clase, que tiene prioridad con respecto al definido en la interfaz. //Result Hello World from HelloWorldClass Si no existe implementación para el método en la clase, siempre se utilizará la implementación del método default más específico definido en las interfaces heredadas public interface Interface1 { default String getHelloWorldStr(){ return “Hello world from Interface 1”; } } public interface Interface2 extends Interface1 { default String getHelloWorldStr(){ return “Hello world from Interface 2”; } } public class HelloWorldClass implements Interface1, Interface2 { public static void main(String[] args) { HelloWorldClass helloWorldClass = new HelloWorldClass (); System.out.println(helloWorldClass.getHelloWorldStr()); } } En este caso, la implementación del método de la interfaz Interface2 es la más específica en la cadena jerárquica, y será la que el compilador seleccione. //Result Hello world from Interface 2 ","date":"25-03-2019","objectID":"/blog/novedades-en-interfaces-java-8/:5:0","tags":["interfaces"],"title":"Java 8: Novedades en interfaces","uri":"/blog/novedades-en-interfaces-java-8/"},{"categories":["java"],"content":"La referenciación a métodos y constructores es otra de las funcionalidades que nos ofrece Java 8, y que nos permite utilizar dichas referencias a modo de expresiones lambda. Estas referencias son lo que en inglés se denomina “syntactic sugar”, y consiste en pequeños añadidos a la sintaxis de Java diseñados para hacer algunas construcciones más fáciles de leer o expresar. Las referencias a métodos y constructores sólo pueden ser utilizadas cuando la interfaz funcional coincide con el patrón del método referenciado. public static void main(String[] args){ // Normal lambda expression Consumer consumer1 = (x) -\u003e System.out.println(x); consumer1.accept(“Hello consumer1”); // Lambda expression with a method reference Consumer consumer2 = System.out::println; consumer2.accept(“Hello consumer2”); } En el siguiente ejemplo podemos ver que el patrón esperado por el compilador en el momento de definir la expresión lambda es la de la interfaz funcional Consumer, que recibe un parámetro de entrada, y no devuelve nada. Esto nos permite hacer referencia a métodos que tengan ese mismo patrón, como el que se hace referencia en el ejemplo, System.out::println. @FunctionalInterface public interface Consumer { // Referenced method void accept(T t); default Consumer\u003cT\u003e andThen(Consumer\u003c? super T\u003e after) { Objects.requireNonNull(after); return (T t) -\u003e { accept(t); after.accept(t); }; } } Al tener la información necesaria para inferir los parámetros de entrada, los parámetros de salida y el comportamiento a aplicar en la expresión lambda, es el compilador el que hace el resto del trabajo por nosotros, pudiendo utilizar las referencias a métodos y constructores sin necesidad de definir cómo queremos utilizar las variables de entrada o salida, como haríamos con una expresión lambda basada en una interfaz funcional. Las reglas para utilizar las referencias mencionadas en expresiones lambda se pueden dividir en tres: Referencias a métodos estáticos Referencias a métodos sobre una instancia de un objeto Referencias a métodos sobre la instancia del objeto sobre el cual se crea la expresión lambda Reglas aplicables al referenciar métodos en expresiones lambda A continuación se puede encontrar un ejemplo de cada una de las reglas listadas en la imagen anterior: Ejemplo de referencias a métodos en expresiones lambda De la misma forma, para hacer referencia a un constructor, utilizamos la misma lógica anterior, utilizando la palabra clave new para instanciar el objeto. public static void main(String[] args){ // Normal constructor call Factory\u003cList\u003e f = () -\u003e return new ArrayList(); // Constructor reference call Factory\u003cList\u003e f = ArrayList::new; } ","date":"18-03-2019","objectID":"/blog/referencias-metodos-constructores-java-8/:0:0","tags":["constructor-reference","method-reference"],"title":"Java 8: Referencias a métodos y constructores","uri":"/blog/referencias-metodos-constructores-java-8/"},{"categories":["java"],"content":"Las interfaces funcionales son todas aquellas interfaces que definen un único método abstracto, pudiendo implementar uno o varios métodos default o static. Este nuevo tipo de interfaces son especialmente importantes debido a que son la base de la implementación de las nuevas expresiones lambda, una de las funcionalidades más importantes de Java 8. A continuación podemos ver un ejemplo de interfaz funcional, en la que se define un único método abstracto, y varios métodos default y static: public interface Calculator { // My abstract method String calculate(int arg1, int arg2); // Default method default int sum(int arg1, int arg2) { return arg1 + arg2; } // Static method static int floatToInt(float arg) { return Math.round(arg); } } Para asegurarnos de que nuestra interfaz funcional está bien implementada, Java 8 ha incluido una anotación que nos permite verificarlo, para ello deberemos incluir la anotación @FunctionalInterface a nivel de la clase. Esta anotación es procesada por nuestro IDE, y nos marcará si la interfaz está correctamente implementada. @FunctionalInterface public interface Calculator { // My abstract method String calculate(int arg1, int arg2); } ","date":"11-03-2019","objectID":"/blog/interfaces-funcionales-java-8/:0:0","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/blog/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Ejemplos de interfaces funcionales incluidas en Java 8 Java 8 incluye múltiples interfaces funcionales que podemos utilizar para crear expresiones lambda, y que son muy utilizadas en la API de Streams de Java. Podemos encontrar estas interfaces en el paquete java.util.function. Sin entrar en cada una de ellas, a continuación os dejo ejemplos de las interfaces nuevas que se han incluido en la versión de Java 8. ","date":"11-03-2019","objectID":"/blog/interfaces-funcionales-java-8/:1:0","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/blog/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaces Consumer y BiConsumer\u003cT,U\u003e Las interfaces Consumer y BiConsumer representan una operación que recibe uno y dos valores respectivamente, y no devuelven ningún resultado. @FunctionalInterface public interface Consumer { void accept(T t); default Consumer\u003cT\u003e andThen(Consumer\u003c? super T\u003e after) { Objects.requireNonNull(after); return (T t) -\u003e { accept(t); after.accept(t); }; } } @FunctionalInterface public interface BiConsumer\u003cT,U\u003e { void accept(T t, U u); default BiConsumer\u003cT,U\u003e andThen(BiConsumer\u003c? super T,? super U\u003e after) { Objects.requireNonNull(after); return (T t, U u) -\u003e { accept(t,u); after.accept(t,u); }; } } ","date":"11-03-2019","objectID":"/blog/interfaces-funcionales-java-8/:1:1","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/blog/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaz Supplier La interfaz Supplier representa un proveedor de resultados, sin parámetros de entrada y con un parámetro de salida. @FunctionalInterface public interface Supplier { T get(); } ","date":"11-03-2019","objectID":"/blog/interfaces-funcionales-java-8/:1:2","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/blog/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaces Function y BiFunction\u003cT,U\u003e Las interfaces Function y BiFunction representan una función que recibe uno y dos valores respectivamente, y produce un valor como resultado. @FunctionalInterface public interface Function\u003cT,R\u003e { R apply(T t); default \u003cV\u003e Function\u003cV, R\u003e compose(Function\u003c? super V, ? extends T\u003e before) { Objects.requireNonNull(before); return (V v) -\u003e apply(before.apply(v)); } default \u003cV\u003e Function\u003cT, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after) { Objects.requireNonNull(after); return (T t) -\u003e after.apply(apply(t)); } static \u003cT\u003e Function\u003cT, T\u003e identity() { return t -\u003e t; } } @FunctionalInterface public interface BiFunction\u003cT, U, R\u003e { R apply(T t, U u); default \u003cV\u003e BiFunction\u003cT, U, V\u003e andThen(Function\u003c? super R, ? extends V\u003e after) { Objects.requireNonNull(after); return (T t, U u) -\u003e after.apply(apply(t, u)); } } ","date":"11-03-2019","objectID":"/blog/interfaces-funcionales-java-8/:1:3","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/blog/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaz UnaryOperator La interfaz UnaryOperator representa una operación en la cual se recibe un parámetro de entrada, y se devuelve un valor del mismo tipo como resultado. @FunctionalInterface public interface UnaryOperator extends Function\u003cT, T\u003e { static UnaryOperator identity() { return t -\u003e t; } } ","date":"11-03-2019","objectID":"/blog/interfaces-funcionales-java-8/:1:4","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/blog/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaz BinaryOperator La interfaz BinaryOperator representa una operación en la cual se reciben dos parámetro de entrada del mismo tipo, y se devuelve un valor del mismo tipo como resultado. @FunctionalInterface public interface BinaryOperator extends BiFunction\u003cT,T,T\u003e { public static BinaryOperator minBy(Comparator\u003c? super T\u003e comparator) { Objects.requireNonNull(comparator); return (a, b) -\u003e comparator.compare(a, b) \u003c= 0 ? a : b; } public static \u003cT\u003e BinaryOperator\u003cT\u003e maxBy(Comparator\u003c? super T\u003e comparator) { Objects.requireNonNull(comparator); return (a, b) -\u003e comparator.compare(a, b) \u003e= 0 ? a : b; } } ","date":"11-03-2019","objectID":"/blog/interfaces-funcionales-java-8/:1:5","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/blog/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Interfaces Predicate y BiPredicate Las interfaces Predicate y BiPredicate representan funciones que devuelven un booleano como resultado, y reciben uno y dos parámetros de entrada respectivamente. @FunctionalInterface public interface Predicate { boolean test(T t); default Predicate\u003cT\u003e and(Predicate\u003c? super T\u003e other) { Objects.requireNonNull(other); return (t) -\u003e test(t) \u0026\u0026 other.test(t); } default Predicate\u003cT\u003e negate() { return (t) -\u003e !test(t); } default Predicate\u003cT\u003e or(Predicate\u003c? super T\u003e other) { Objects.requireNonNull(other); return (t) -\u003e test(t) || other.test(t); } static \u003cT\u003e Predicate\u003cT\u003e isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -\u003e targetRef.equals(object); } } @FunctionalInterface public interface BiPredicate\u003cT, U\u003e { boolean test(T t, U u); default BiPredicate\u003cT, U\u003e and(BiPredicate\u003c? super T, ? super U\u003e other) { Objects.requireNonNull(other); return (T t, U u) -\u003e test(t, u) \u0026\u0026 other.test(t, u); } default BiPredicate\u003cT, U\u003e negate() { return (T t, U u) -\u003e !test(t, u); } default BiPredicate\u003cT, U\u003e or(BiPredicate\u003c? super T, ? super U\u003e other) { Objects.requireNonNull(other); return (T t, U u) -\u003e test(t, u) || other.test(t, u); } } ","date":"11-03-2019","objectID":"/blog/interfaces-funcionales-java-8/:1:6","tags":["functional-interfaces"],"title":"Java 8: Interfaces funcionales.","uri":"/blog/interfaces-funcionales-java-8/"},{"categories":["java"],"content":"Las expresiones lambda son una de las múltiples funcionalidades nuevas que nos ofrece Java 8. Estas expresiones son parte de los primeros pasos de Java hacia la programación funcional, y su cometido es introducirnos a las funciones anónimas mediante las cuales podemos definir el comportamiento de los objetos, y los datos que encapsulan. ¿En qué consiste la programación funcional? La programación funcional es un paradigma de programación basado en las funciones matemáticas, que especifica que una función que recibe un parámetro X, siempre devolverá un resultado Y. Este paradigma permite definir comportamiento mediante funciones, pudiendo inyectarlo como parámetro de entrada en los objetos, o devolverlo como resultado de otro método. ","date":"03-02-2019","objectID":"/blog/expresiones-lambda-java-8/:0:0","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/blog/expresiones-lambda-java-8/"},{"categories":["java"],"content":"Introducción a las funciones lambda Por tanto, deducimos de lo anterior, que las funciones lambda son la funcionalidad que Java ofrece para facilitar la definición de comportamiento mediante parámetros. Una función lambda consta de los siguientes elementos: Parámetros de entrada Operador lambda Cuerpo del método Ejemplo de expresión lambda El primer elemento de la expresión lambda, los parámetros de entrada se puede definir como: Expresión lambda sin parámetros de entrada () -\u003e System.out.println(“Hello Lambda World!”) Expresión lambda con un parámetro de entrada simple x -\u003e x + 10 Expresión lambda con múltiples parámetros de entrada (int x, int y) -\u003e { return x + y; } ﻿ Con respecto al cuerpo del método, para los métodos con una única línea de código no es necesario definir las llaves. // Expresión lambda con dos parámetros de entrada sin return definido (String x, String y) -\u003e x.length() - y.length() Mientras que para métodos con varias líneas, las llaves serán obligatorias. // Expresión lambda con varias líneas de código como cuerpo (String x) -\u003e { //Code… return x.length(); }﻿ ","date":"03-02-2019","objectID":"/blog/expresiones-lambda-java-8/:1:0","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/blog/expresiones-lambda-java-8/"},{"categories":["java"],"content":"Referenciando variables externas Las expresiones lambda pueden hacer referencia a variables locales finales, o efectivamente finales dentro de la clase donde se definen. ¿Y qué es eso de variables efectivamente finales? Las variables efectivamente finales son variables que, aunque no se definen explícitamente como finales, cumplen los requisitos para poder serlo. En el siguiente ejemplo podemos ver cómo se utiliza la variable “before” , una variable efectivamente final, dentro de la expresión lambda que filtra los resultados de la lista de ficheros. //Utilizando variables efectivamente finales dentro de funciones lambda void expire(File root, long before) { root.listFiles(File p -\u003e p.lastModified() \u003c= before); } ","date":"03-02-2019","objectID":"/blog/expresiones-lambda-java-8/:1:1","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/blog/expresiones-lambda-java-8/"},{"categories":["java"],"content":"Referencia “this” en las funciones lambda El uso de “this” en las expresiones lambda hace referencia al objeto en el cual se ha definido la expresión. Siguiendo con el ejemplo anterior, se podría definir una variable final en el objeto que encapsula al método “expire”, y utilizar “this” para hacer referencia a dicha variable. //Referenciando a ’this’ dentro de una función lambda public final long currentDate = new Date().getTime(); void expire(File root) { root.listFiles(File p -\u003e p.lastModified() \u003c= this.currentDate); } Esto es así debido a que las expresiones lambda no son más que una representación de funciones anónimas, y estas no están asociadas a ninguna clase, por tanto, una función lambda no puede referenciarse a sí misma. ","date":"03-02-2019","objectID":"/blog/expresiones-lambda-java-8/:1:2","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/blog/expresiones-lambda-java-8/"},{"categories":["java"],"content":"Creando nuestra propia expresión lambda con interfaces funcionales Ahora que ya sabemos cómo funcionan las expresiones lambda, podemos empezar a crear las nuestra. Para ello utilizaremos interfaces funcionales. Las interfaces funcionales son aquellas que definen un único método abstracto. Las interfaces funcionales también pueden definir a su vez tantos métodos estáticos y métodos default como sean necesarios. Para crear nuestra interfaz funcional, deberemos utilizar la anotación @FunctionalInterface. @FunctionalInterface public interface Math{ int calculate(int x, int y); } Una vez creada nuestra interfaz funcional, podremos instanciarla utilizando una expresión lambda, tal y como se define a continuación: public class Test{ public static void main(String\\[\\] args){ executeMath(5,3,(x,y)-\u003ex\\*y); } public int executeMath(int x, int y, Math math){ return math.calculate(x, y); } } Si quieres saber más acerca de las interfaces funcionales puedes hacerlo aquí. ","date":"03-02-2019","objectID":"/blog/expresiones-lambda-java-8/:1:3","tags":["lambda-expressions","functional-programming"],"title":"Java 8: Expresiones Lambda","uri":"/blog/expresiones-lambda-java-8/"}]